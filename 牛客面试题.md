[TOC]

# redis

## redis为什么这么快

**基于内存操作**

单线程**省去CPU切换上下文的时间**，不需要考虑锁的问题。

IO多路复用



## redis单线程还是多线程的

Redis中**数据操作模块是单线程的**，也就是。只有**网络请求模块和数据操作模块是单线程的**。而其他的如**持久化存储模块、集群支撑模块、删除对象等是多线程的。Redis 6.0的多线程只用来处理网络IO从 socket 中读数据和写数据不再由主线程负责，而是交给了多个子线程，这样就可以使多个 socket 的读写并行化了。**而数据的读写还是单线程。



**首先 epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个队列中，Redis 主线程会对该事件队列不断进行处理，这样一来 Redis 就无需一直轮询是否有请求发生，从而避免资源的浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。**



### Redis 6.0 的主线程和子线程之间是如何协同的

**阶段一：服务端和客户端建立 socket 连接，并分配子线程（处理线程）**

首先，主线程负责接收建立连接请求，当有客户端请求到达时，主线程会创建和客户端的 scoket 连接，该 socket 连接就是用来和客户端进行数据的传输的。只不过这一步不由主线程来做，主线程要做的事情是将该 **socket 放入到全局等待队列中，然后通过轮训的方式选择子线程**，并将队列中的 socket 连接分配给它，所以**无论是从客户端读数据还是向客户端写数据，都由子线程来做**。因为我们说 Redis 6.0 中引入多线程就是为了**缓解主线程的 I/O 读写压力**，而 I/O 读写这一步是阻塞的，所以应该交给子线程并行操作。

**阶段二：子线程读取并解析请求**

**主线程一旦把 socket 连接分配给子线程，那么会进行阻塞状态，等待子线程完成客户端请求的读取和解析，得到具体的命令操作。**由于可以有多个子线程，所以这个操作很快就能完成。

**阶段三：主线程执行命令操作**

等到子线程读取到客户端请求并解析完毕之后，然后**再由主线程以单线程的方式执行命令操作**，I/O 读写虽然交给了子线程，但是命令本身还是由 Redis 主线程执行的。

**阶段四：子线程回写 socket、主线程清空全局队列**

当主线程执行完命令操作时，还需要将结果写入缓冲区，而这一步显然要由子线程来做，因为是 I/O 读写。此时主线程会陷入阻塞，直到子线程将这些结果写回 socket 并返回给客户端。



## redis 五种数据类型

```bash
# 字符串命令
set k1 v1
set k1 v1 ex 60 # 过期时间60秒
keys * # 显示所有的键

# 哈希
hset dict k1 v1 k2 v2 k3 v3 # 设置key为dict 值为k1,v1;k2,v2;k3,v3
hgetall dict # 查询dict保存的所有键值
hget dict k1 # 查询dict的k1的值(v1)
hlen dict # 长度
HKEYS dict # 获取dict中所有的字段
HVALS dict # 获取dict中所有的值

# 列表 按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
lpush list redis # 在list中左边插入redis
rpush list mongodb # 在list中右边插入mongodb
llen # 长度
lpop list # 在list的左边移除第一个元素
rpop list # 在list的右边移除第一个元素
lindex list 0 # 通过索引获取列表中的元素
lrange list 0 -1 # 查看list中的所有元素

# 集合（set）无序集合，集合中不能出现重复的数据
sadd sets redis # 添加元素
smembers sets # 集合中的所有成员
srem sets redis # 移除集合中的redis元素
sismember sets redis # 判断redis是否是集合中的成员

# 有序集合和set一样也是 string 类型元素的集合,且不允许重复的成员，分数可以重复。
zadd mysortset 1 redis # 添加元素
zcard mysortset # 获取有序集合的成员数

# Geo 地理位置 朋友的定位，附近的人
geoadd china:city 116.40 39.90 beijing
geoadd china:city 121.47 31.23 shanghai # 添加地理位置
genpos china:city beijing # 获取北京的经度和纬度！
geodist china:city beijing shanghai km # 查看北京到上海的直线距离,以km为单位
genradius china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市

# HyperLogLog

# Bitmap 位图 统计用户在线天数
```



## redis实现分布式锁

在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。

主要保证**互斥性**和**避免死锁**

+ 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。

- 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
- 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。



命令：SET key value ex 5 nx 或者使用 lua 脚本

ex 5 表示过期时间，nx表示不存在的情况下创建锁。

### 锁误解除

如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，**线程 A 实际释放的线程 B 加的锁。**

解决方法：在 value 中设置当前线程加锁的标志，删除 key 对应的 value 是否是当前线程拥有。可生成一个 UUID 标识当前线程。



### 超时解锁导致并发

如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，**线程 A 和线程 B 并发执行**。

+ 将**过期时间设置足够长**，确保代码逻辑在锁释放之前能够执行完成。
+ 为获取锁的线程**增加守护线程**，为将要过期但未释放的锁增加有效时间。



### 不可重入性

使用 ThreadLocal 进行重入次数统计。



## 内存淘汰策略

> 在配置文件中，通过maxmemory-policy可以配置要使用哪一个淘汰机制。

noeviction: 当内存不足以容纳新写入数据时，新写入操作会**报错**。

allkeys-lru：当内存不足以容纳新写入数据时，在键空间（`server.db[i].dict`）中，**移除最近最少使用的 key**（这个是最常用的）。

allkeys-random：当内存不足以容纳新写入数据时，在键空间（`server.db[i].dict`）中，**随机移除某个 key**。

volatile-lru：当内存不足以容纳新写入数据时，**在设置了过期时间的键空间（`server.db[i].expires`）中，移除最近最少使用的 key**。

volatile-random：当内存不足以容纳新写入数据时，**在设置了过期时间的键空间（`server.db[i].expires`）中，随机移除某个 key**。

volatile-ttl：当内存不足以容纳新写入数据时，**在设置了过期时间的键空间（`server.db[i].expires`）中，有快要过期的 key 优先移除。**



## 过期删除策略

1. 定时删除：

   对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。缺点是**占用了大量的CPU资源**去处理过期的数据，会影响Redis的吞吐量和响应时间。

2. 惰性删除

   当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地**节省CPU资源，但是对内存却十分不友好**。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。

3. 定期删除

   **每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。**该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。

Redis的过期删除策略就是：**惰性删除和定期删除两种策略配合使用。**



## Redis除了用作缓存还可以做什么

+ 消息队列：使用 list 列表。
+ 排行榜：使用zset，score表示点击次数。
+ 用户签到记录：使用位图



## redis底层数据结构

+ 动态字符串SDS。主要有三个参数：len，**free**，buffer。

  

  ![image-20210707093139002](牛客面试题.assets/image-20210707093139002.png)

  空间预分配：（1）如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。
  （2）如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

  惰性空间释放策略：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来

+ 链表。list 和 listNode 组成链表。list 主要包括**头结点和尾结点**，这两个节点都是listNode类型的

listNode 主要包括前驱，后继以及当前节点的值。

![image-20210707093747259](牛客面试题.assets/image-20210707093747259.png)

![image-20210707093759354](牛客面试题.assets/image-20210707093759354.png)



+ 字典。哈希表数组，哈希表大小，哈希表已有节点数量。**dictEntry的key属性保存着键值对中的键，而v属性则保存着键值对中的值**，next指向另一个哈希表节点的指针，为了解决冲突的。

![image-20210707094527514](牛客面试题.assets/image-20210707094527514.png)

![image-20210707094637264](牛客面试题.assets/image-20210707094637264.png)

+ 跳跃表：链表中所有元素都是排序的。查找时，可以从顶级链表中开始查找，发现查找的元素大于本层元素，转入下一层链表进行查找。

  zskiplist结构，该结构包含以下属性：header：指向跳跃表的表头节点。tail：指向跳跃表的表尾节点。level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。zskiplistNode结构是节点的数据结构：**level 数组记录了每一层链表的下一个位置。**节点的后退指针（backward属性）用于从表尾向表头方向访问节点。以及分数。

+ 整数集合：

  ![image-20210708094046911](牛客面试题.assets/image-20210708094046911.png)

  主要是**contents数组，保存所有的元素**

+ 压缩列表和各种语言的数组类似，它是**由连续的内存块组成的**，这样一来，由于内存是连续的，就减少了很多内存碎片和指针的内存占用，**进而节约了内存**。

  ![image-20210708094855875](牛客面试题.assets/image-20210708094855875.png)

  **元素的遍历：先找到列表尾部元素**，然后再根据ziplist节点元素中的`previous_entry_length`属性（**记录前一个节点的长度**），来逐个遍历:

Redis使用对象来表示数据库中的键和值，**每当在Redis的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）**。**键总是一个字符串对象**，而值的话则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。

+ 对象：Redis并没有直接使用上述数据结构来实现键值对数据库，而是基于这些数据结构**创建了一个对象系统**，这个系统包含**字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象**，每种对象都**用到了至少一种**我们前面所介绍的数据结构。

  字符串对象保存的可以使 long 类型的整数，或者**动态字符串SDS**

  列表对象可以使用压缩列表或者**链表**

  哈希对象可以使用压缩列表或者**字典**

  集合对象可以使用**整数集合**或者**字典**，字典的key为集合原色的值，value为空。

  有序集合对象可以压缩链表或者**字典(value 保存分数)+跳跃表**。

  除了字符串对象和**集合对象**，都要使用到压缩列表。



## 有序集合为什么用跳表不用红黑树

跳表的复杂度和红黑树一样，而且实现起来更简单，插入删除元素可能还会导致子树的调整。

按照**范围区间**来查找数据时，红黑树没有跳表快。



## 跳表的插入操作

在插入元素之后，我们可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法**有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推**。

- randomLevel() 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）
- randomLevel() 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）
- randomLevel() 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）
- randomLevel() 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）




## redis一致性

**强一致性**：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大

**弱一致性**：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

**最终一致性**：最终一致性是弱一致性的一个特例，系统**会保证在一定时间内**，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型



采用的方案是**先写入数据库，再删除缓存**。（删除缓存失败，将binlog日志发送到MQ队列中，然后通过ACK机制处理消息）

**错误方案1：**删除缓存，再写数据库：**线程A，先删除缓存，但是还没有写到数据库中**，**线程B读取数据**，缓存没有命中，然后读取数据库的老数据，然后**设置老数据到缓存中**，线程A写到数据库中，此时数据库和缓存就不一致了。

**错误方案2：**设置缓存，再写入数据库：**如果线程A先于线程B写数据库**，**A先设置缓存，然后B设置缓存，写数据库，最后A再写数据库**。此时缓存的是B线程写的数据，数据库中是A线程的写数据，不一致了。



## 持久化机制

**RDB：**

 `BGSAVE` 命令，Redis 会调用 **fork 创建一个子进程**，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。

 `SAVE` 命令，此时 Redis 将开始**创建快照**，并且在完成之前不再响应其它命令，**也就是阻塞中**。

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。按照一定的时间将内存的数据以快照的形式保存到硬盘中。RDB 是间隔一段时间进行持久化，**如果持久化之间 redis 发生故障，会发生数据丢失**。

save 配置选项，比如 `save 60 10000`，那么从 Redis 最近一次创建快照算起，当 “60 秒内有 10000 次写入” 这个条件被满足时， Redis 就会自动触发 `BGSAVE` 命令。

**AOF：**

将Redis执行的每次**写命令**记录到单独的日志文件中。

可以指定 `appendfsync` 以何种方式让数据完全同步到硬盘，这个配置有 3 个选项：

1. always： 每个 Redis 写命令都**立即同步**到硬盘，这是比较消耗性能的
2. everysec： **每秒执行一次同步**，兼顾性能与数据安全，是比较常用的选项
3. no： **让操作系统决定**何时进行同步



**过期键及其持久化**

同时开启时，数据恢复Redis会**优先选择AOF恢复**，文件比RDB大恢复速度慢，启动效率低。

在载入 RDB 的时候，要分两种情况：

1. 如果 Redis 以**主服务器**的模式运行，那么会对 RDB 中的键进**行时间检查，过期的键不会被恢复到** Redis 中。
2. 如果 Redis 以**从服务器**的模式运行，那么 RDB 中**所有的键都会被载入**，忽略时间检查。在从服务器与主服务器进行数据同步的时候，**从服务器的数据会先被清空**，所以载入过期键不会有问题。

在载入 AOF  的时候，**添加过期键**

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。**当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。**



## 缓存异常

### 缓存雪崩

**缓存雪崩**是指缓存同一时间大面积的失效。

缓存数据的**过期时间设置随机在原来的基础上增加一个随机值**。加锁排队。

### 缓存穿透

**缓存和数据库中都没有的数据**。

使用**布隆过滤器**，一个，一个一定不存在的数据会被 这个bitmap拦截掉

另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个**查询返回的数据为空**（不管是数 据不存在，还是系统故障），我们仍然**把这个空结果进行缓存**，但它的**过期时间会很短**，最长不超过五分钟。

### 缓存击穿

缓存中没有但数据库中有的数据。

设置**热点数据永不过期**。就是在缓存失效的时候（判断拿出来的值为空），不是立即去访问数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如**Redis的SETNX**或者Memcache的ADD）去set一个mutex key，**当操作返回成功时，再进行数据库的操作并回设缓存**，否则，就重试整个get缓存的方法。


### 缓存预热

当访问量剧增、服务出现问题，系统可以根据一些关键数据进行自动降级

### 缓存降级



## 延迟队列

使用sortedset，使用时间戳做score。每秒扫描一次集合，取出执行时间小于等于当前时间的任务



## Redis 主从复制

当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。

如果这是 slave node **初次连接**到 master node，那么会触发一次 full resynchronization **全量复制**。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件。

同时还会将从客户端 client 新收到的所有**写命令缓存在内存中**。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，

接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。

slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。



## 部分重同步的实现

### 复制偏移量

主服务器和从服务器会分别维护一个复制偏移量：

主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量加 N

从服务器每次收到主服务器传播的 N 个字节的数据时，就将自己的复制偏移量加 N

通过复制偏移量可以很容易知道主从服务器是否处于一致状态，如果**主从服务器的复制偏移量处于一致情况，那么主从服务器处于一致情况**。

### 复制挤压缓冲区

复制积压缓冲区是由主服务器维护的一个**固定长度**（fixed-size）先进先出（FIFO）**队列**，默认大小为1MB。主服务器的**复制积压缓冲区里面会保存着一部分最近传播的写命令**，并且复制积压缓冲区会为队列中的每个字节**记录相应的复制偏移量**。

+ 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区**里面，那么主服务器将对从服务器执行**部分重同步**操作。
+ 相反，如果offset偏移量之后的数据已经**不存在于复制积压缓冲区**，那么主服务器将对从服务器执行**完整重同步**操作。

### 服务器运行ID

每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。当从服务器对主服务器进行初次复制时，**主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来**。当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器**发送之前保存的运行ID：**

+ 如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID **相同**，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以**继续尝试执行部分重同步**操作。
+ 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID**并不相同**，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行**完整重同步操作。**



## 心跳检测

从服务器默认会以每秒一次的频率，向主服务器发送命令：REPLCONF ACK [replication_offset]

主要有三个作用：

1. 检测主从服务器的网络连接状态。
2. 辅助实现min-slaves选项（Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令）。
3. 检测命令丢失。



## sentinel哨兵

每个发现主服务器进入客观下线的 Sentinel 都会要求其他Sentinel将自己设置为局部领头 Sentinel 。如果有某个 Sentinel 被**半数以上**的 Sentinel 设置成了局部领头 Sentinel ，那么这个 Sentinel 成为**领头 Sentinel** 。

+ Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。
+ 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。
+ 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。



# MySQL

## 三大范式

第一范式：每一列都是不可分割的基本数据项，同一列中不能有多个值。

第二范式：非主属性必须**完全依赖于主键**，而不能依赖于主键的一部分。

第三范式：属性**不依赖于其他非主属性**。



## explain 关键字

type  属性。const（主键或者唯一二级索引） eq_ref(唯一索引扫描) ref（普通二级索引对常量进行等值匹配）rows：扫描行数

key 属性实际使用到的索引。



## 索引相关的sql语句

```sql
SHOW INDEX FROM table;
ALTER TABLE table_name ADD INDEX index_name (column_list);
ALTER TABLE table_name DROP INDEX index_name (column_list);
CREATE INDEX index_name ON table_name (column_list);
```



## B+树和B树、哈希索引、跳表

哈希索引：如果等值查询，哈希索引有一定的优势。如果是范围查询所有，哈希索引就没有用处了，也没有办法完成排序。

B树遍历元素效率太低。因为叶子结点不保存信息，非叶子结点保存信息。

为什么MySQL不使用跳表？主要原因是MySQL的数据是保存在磁盘上，而redis的数据是保存在内存中的，如果使用跳表，查找高层的节点**随机IO 会浪费较长的时间**，而内存的话就没有这个顾虑。



## 建索引的几大原则

+ 索引不是越多越好
+ 为经常需要排序、分组和联合操作的字段建立索引
+ 为常作为查询条件的字段建立索引
+ 最左前缀匹配原则



## MySQL优化

+ 使用explain查看SQL执行计划。type ：查询速度。key：使用的索引名字。rows：扫描行数，估计值
+ 尽量不要使用select * ，直接在select后面接上字段名
+ 当只需要一条数据的时候，使用limit 1
+ 当分页过大的时候，可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。如：select id,name from table_name where id> 866612 limit 20
+ 不使用%最为前缀查询，会导致索引失效
+ 对于联合索引来说，要遵守**最左前缀法则**



## 索引失效的情况

+ **联合索引**违反最左前缀法则
+ 函数导致不走索引
+ 索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描
+ 如果or连接的所有条件字段都设置了索引，那么还是会走索引的；一旦有一个条件没有建立索引，那么就会走全表扫描。



## 慢查询优化

explain命令

加索引

开启慢查询日志，开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？ 这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，可以使用命令修改。

```sql
**查看慢SQL是否启用**：
set global log_slow_queries = on; 
set global long_query_time =1;
```





## 锁

**行级锁或者行锁**：

- 共享锁（读锁）：其他事务可以读，但不能写。
- 排他锁（写锁） ：其他事务不能读取，也不能写。
- 隔离锁（gap Lock）：防止幻读，不允许别的事务在当前记录前面的间隙插入新纪录。
- next-key lock：锁住某条记录，同时防止其他事务在该记录的前面插入新纪录。

共享锁和排它锁都是针对记录的，也可以成为**行级锁或者行锁**。事务也可以在表级别加锁，称之为表级锁或者表锁。给表加的锁也可以分为共享锁和排它锁。

意向共享锁(IS)、意向排他锁(IX)：快读判断表中的记录是否被上锁。一个事务给一个数据行加共享锁时，必须先获得表的IS锁。一个事务给一个数据行加排他锁时，必须先获得该表的IX锁。

Innodb在的**默认级别是不可重复读**，此时**会用next key lock即锁住某条记录，防止幻读**。



## 事务的四种隔离级别

| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--------------------------- | :----------------- | :------------------------------- | :------------------- |
| 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

- 未提交读(Read Uncommitted)：允许**脏读，也就是可能读取到其他会话中未提交事务修改的数据**
- 提交读(Read Committed)：只能**读取到已经提交的数据**。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

脏读：**读取未提交数据**。

不可重复读：一开始事务A读取了一条记录，此时**事务B修改了这条记录并提交**，事务A再次读取这条记录，发现**前后两次读取的记录不一致**。

幻读：事务A先读取记录的条数，此时事务B又添加了几条记录并提交，事务A再次查询记录的条数，发现记录数变多，平白无故多了一些记录，就是幻读。



## ACID及其实现

+ 一致性：**指系统从一个正确的状态,迁移到另一个正确的状态。**原子性，持久性和隔离性目的是一致性。

+ 原子性：**undo log** 是实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的 undo log ；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。

  undo log属于逻辑日志，它记录的是sql执行相关的信息。**当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。**

+ 持久性：实现原理：**redo log**。当向**数据库写入数据时，会首先写入Buffer Pool**，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

  Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：**如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失**，事务的持久性无法保证。

  于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

  既然redo log也需要在事务提交时将日志写入磁盘，**为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？**主要有以下两方面的原因：

  （1）刷脏是随机IO，因为**每次修改的数据位置随机**，但写redo log是追加操作，**属于顺序IO。**

  （2）刷脏是**以数据页（Page）为单位的**，MySQL默认页大小是16KB，**一个Page上一个小修改都要整页写入**；而redo log中**只包含真正需要写入的部分**，无效IO大大减少。

+ 隔离性：

  (一个事务)写操作对(另一个事务)写操作的影响：**锁机制**保证隔离性
  (一个事务)写操作对(另一个事务)读操作的影响：**MVCC**保证隔离性



## MVCC 多版本并发控制原理

聚簇索引记录中有**两个必要的隐藏列：保存事务ID，指向undo日志**，每条undo日志也会指向上一个条undo日志。

ReadView用来存储活跃中事务的最小值、最大值、**系统中当前活跃着的读写事务**，其中还记录了产生当前ReadView的事务ID

+ 如果记录中的**事务ID**小于产生ReadView的**活跃事务的最小值**，表明修改产生该记录的事务之前就已经提交，可以访问。
+ 如果记录中的事务ID值大于等于产生ReadView的**活跃事务最大值**，表明修改产生该记录的事务生成ReadView之后产生的。
+ ReadView的**活跃事务的最小值**和**活跃事务最大值**之间，判断是否活跃，如果活跃不可访问，不活跃便可以访问。

如果**不可见就通过版本链找到下一个版本。**

已提交读和可重复读的区别就在于它们生成ReadView的策略不同：

+ 已提交读**每次**读取数据都会产生ReadView
+ 可重复读只会在**第一次**执行查询语句时生成ReadView



## redo日志原理

redo log 也包括两部分：一是内存中的**日志缓冲(redo log buffer)，该部分日志是易失性的**；二是磁盘上的**重做日志文件(redo log file)，该部分日志是持久的**。redo log是物理日志，记录的是数据库中物理页的情况 。当数据发生修改时，InnoDB**不仅会修改Buffer Pool中的数据，也会在redo log buffer记录这次操作**；当事务提交时，**会对redo log buffer进行刷盘，记录到redo log file中。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。**这样就不需要每次提交事务都实时进行刷脏了。



**什么是LSN?**

LSN也就是log sequence number，也日志的序列号，是一个单调递增的64位无符号整数。redo log和数据页都保存着LSN，可以用作数据恢复的依据。LSN更大的表示所引用的日志记录所描述的变化发生在更后面。

**什么是Checkpoint？**

Checkpoint**表示一个保存点，在这个点之前的数据页的修改**（log LSN < Checkpoint LSN）都已经写入磁盘文件了。InnoDB**每次刷盘之后都会记录Checkpoint**，把最新的redo log LSN 记录到**Checkpoint LSN** 里，方便恢复数据的时候作为起始点的判断。

恢复流程：启动InnoDB时，找到最近一次Checkpoint的位置，利用Checkpoint LSN去找大于该LSN的redo log进行日志恢复。



## undo 日志原理

每次插入，删除，更新，都会对应相应的undo日志，在回滚的时候，就可以直接undo日志回滚到事务开始前的状态。

 

## binlog日志

主要是用来记录对mysql数据**更新或潜在发生更新的SQL语句**，并以"事务"的形式保存在磁盘中；

主要有以下两个作用：

- 复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的
- 数据恢复：通过mysqlbinlog工具恢复数据



## MySQL 分布式锁乐观锁悲观锁

### 实现乐观锁

表中的数据库有version字段，每次对数据修改，这个值就要+1。语句更新成功的条件：只有**版本号和之前找出来的一样，才能证明这个库存没有被别人更新过**，才可以更新成功；



### 悲观锁

悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。



## Compact 格式

变长字段长度列表 NULL信息 记录头信息 记录的真实数据

变长字段列表记录了**当前记录的变长字段列表的长度**

允许为null的列的个数位 n ,**用 n 位的bit表示这些列是否为空**。

记录头信息，包括下一个记录的地址，以及该记录是否删除。

真实的列信息，如果列为空，就不需要再填了，因为在Null值列表记录的。



## 存储引擎

### MyISAM存储引擎

不支持**事务，**也不支持**行级锁**和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时，即**写操作需要锁定整个表** 。**索引和记录是分开放的**。

### Memory存储引擎

数据是放在内存中的，并且默认使用HASH 索引 。



## 死锁分析

```sql
SHOW ENGINE INNODB STATUS;   
LATEST DETECTED DEADLOCK 包括了系统最近一次发生死锁时的加锁情况。查看事务的拿锁情况，判断死锁。
```

**查看慢SQL是否启用**：

```sql
set global log_slow_queries = on; 
set global long_query_time =1;
```



## 分布式事务





# java基础

## jdk 和 jre的区别

Java Runtime Environment 包括 Java 虚拟机和 Java 程序所需的**核心类库**等。

Java Development Kit 是提供给 Java 开发人员使用的，**包括了JRE**，还包括了一些**开发工具**，比如**编译工具** javac.exe， 打包工具 jar.exe 等等。



## java的跨平台性 

**一次编译到处运行**

这些系统都有自己对应的虚拟机，只要我们有一份字节码，通过虚拟机可以生成各个平台对饮的机器指令



##  java 代码的运行过程 

java 代码经过 javac 编译器变为 class字节码文件 ，类加载器把字节码加载到虚拟机的方法区中，运行时会在堆中创建对象，调用对象中的方法(**方法区中保存着类中方法的字节码文件**)，执行引擎将保存在方法区中的字节码文件翻译成计算机所能识别的机器码，供CPU里面执行。



## 面向对象和面向过程的区别  

面向过程：功能的执行过程，即**先后顺序**  

面向对象：站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是**具备某些功能的对象。**  



## 访问修饰符

private：在**同一类**内可见。使用对象：变量、方法。注意：**不能修饰外部类**

default：在**同一包**内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

protected：对**同一包**内的类和所有**子类**可见。使用对象：变量、方法。 注意：**不能修饰外部类**

public：对所有类可见。



## final 关键字

#### final 有什么用？

用于修饰类、属性和方法；

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变，这个变量**不可以再指向别的对象**，但是这个变量的**内部是可以变的**。



## java是值传递还是引用传递？

值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中**如果对参数进行修改，将不会影响到实际参数。**
引用传递(pass by reference)是指在调用函数时将实际参数的地址直接传递到函数中，那么**在函数中对参数所进行的修改，将影响到实际参数**。

**Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。**



## this 关键字

+ 普通的直接饮用，相当于当前对象本身
+ 形参与成员变量重名，用 this 来区分
+ 引用本类的构造函数



## super 关键字

+ 普通的直接饮用
+ 子类中的成员**变量或方法**与父类中的成员变量或方法**同名**时，用super进行区分
+ 引用父类构造函数

**子类的构造函数如果没有显示使用super调用父类的构造函数，会隐含调用父类的无惨构造函数。**

```java
class Test1{
    public Test1(){
        System.out.print("1");
    }
}
class Test2 extends Test1{
    public Test2(){
        System.out.print(" 2");
    }
}
public class Test{
    public static void main (String[] args){
        // 输出为 1 2
        Test2 t = new Test2();
    }
}


class Test1{
    public Test1(String s){
        System.out.print("1");
        System.out.print(s);
    }
}
class Test2 extends Test1{
    public Test2(){
        //super("");
        System.out.print(" 2");
    }
}
public class Test{
    public static void main (String[] args){
        // 这里会报错，因为调用的父类的无参构造函数，但是父类却没有无参构造函数
        Test2 t = new Test2();
    }
}
```





## switch 支持的类型

支持byte、short、int、char以及其**包装类**，加上枚举以及String类型（1.7支持持）

**不支持两种浮点类型，Long类型以及boolean类型**



## java8新特性

### Lambda表达式和函数式接口

```java
public void testLambda3() {
        List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");

        Collections.sort(names, (a, b) -> {
            return a.compareTo(b);
        });

        for(String s : names) {
            System.out.print(s + " ");
        }
        System.out.println();
    }
```

函数式接口：函数式接口(Functional Interface)就是**一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口**。最常用的函数式接口就是Comparator。使用方法



### 接口的默认方法和静态方法

默认方法在抽象类中是实现的，**两个接口中定义了一模一样的默认方法，并且一个实现类同时实现了这两个接口，那么必须在实现类中重写默认方法**。

静态方法，**只能通过接口名调用**，不可以通过实现类的类名或者实现类的对象调用。default方法，只能通过接口实现类的对象来调用。下面的例子中虽然world是接口，但可以使用world.hhh()调用它的静态方法。

```java
interface world {
    static void hhh() {
        System.out.println("接口中静态方法中接口中的hhh");
    }
}

interface hello {
    public void ha();
    default void hehe() {
        System.out.println("接口中默认方法中的hehe");
    }
}

public class InterfaceTest implements hello, world{
    @Override
    public void ha() {
        System.out.println("ha");
    }

    @Override
    public void hehe() {
        System.out.println("实现类中的hehe");

    }

    public static void main(String[] args) {
        hello interfaceTest = new InterfaceTest();
        interfaceTest.ha();
        interfaceTest.hehe();
        world.hhh();
    }
}
```



### Stream流

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
        // 获取对应的平方数
        List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().sorted((a, b) -> {return b - a;}).collect(Collectors.toList());
        System.out.println(squaresList);
```



## Comparable 和 Comparator 的区别

Comparable 在 java.lang 包下，是一个接口，内部只有一个方法 **compareTo**()。（**实体类实现**）

实现了 Comparable 接口的 List 或则数组可以直接使用 `Collections.sort()` 或者 `Arrays.sort()` 方法进行排序。



Comparator 定制排序，向Collections.sort(), Arrays.sort()传入Comparator 接口的实现类。**（无法修改实体类时，直接在调用方创建）**



## javaIO

InputSream类结构图：

![image-20210709193814722](牛客面试题.assets/image-20210709193814722.png)

OutputStream类结构图：

![image-20210709193906470](牛客面试题.assets/image-20210709193906470.png)



FileInputStream BuffedInputStream。**加了Buffered用了缓冲区**，每次先将一部分数据放进缓冲区，需要使用数据再从缓冲区中拿出来，而FileInputStream每次read就读取进行一次IO操作，速度相对来说较慢。

FileReader 和 BufferReader 类似，**加了Buffered用了缓冲区**。

BufferedInputStream 和 BufferedReader 一个是针对字节流，一个是针对字符流。

字节流是1个字节；字符char是两个字节通常用来处理文本数据。



## Try catch

### try-catch-finally中，可以只有try-catch，也可以只有try-finally。

![image-20210709194727307](牛客面试题.assets/image-20210709194727307.png)

如上的代码块，如果报空指针异常，先完成 finally 中的内容，然后再抛出异常。



### try代码块中return

假设利用 return 语句从 try 语句块中退出。在方法返回前，finally子句的内容将被执行。

+ 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。



![image-20210709195546253](牛客面试题.assets/image-20210709195546253.png)



## try-with-resource结构

![image-20210709195155646](牛客面试题.assets/image-20210709195155646.png)

将资源文件放在 try 的括号中，前提是要实现AutoCloseable接口。



## String，StringBuffer，StringBuilder区别

String是字符串常量，是不可改变的，**对该字符串操作都会产生一个新的字符串常量**。 **StringBuffer线程在方法前加synchronized保证线程安全**和**StringBuilder不安全。**



## java四种引用：强软弱虚

强引用：程序内存不足（OOM）的时候也不会被回收  

软引用：在**程序内存不足时，会被回收**  

弱引用：不管内存是否足够，**只要发生GC，都会被回收**

虚引用：只要GC就会被回收。被JVM回收后被传入ReferenceQueue中  



## 异常

`Exception`又分为两大类：

1. `RuntimeException`以及它的子类；
2. 非`RuntimeException`（包括`IOException`、`ReflectiveOperationException`等等）

![image-20210715150136690](牛客面试题.assets/image-20210715150136690.png)

不需要捕获的异常，包括`Error`及其子类，`RuntimeException`及其子类。

`Exception`及其子类，但不包括`RuntimeException`及其子类要捕获



常见的运行时异常：ArithmeticException（算数运算异常，除0的时候）、ArrayIndexOutOfBoundsException（数组越界）、NullPointerException（空指针异常）、ClassCastException（类型强制转换异常）、



# java动态代理

## jdk动态代理

```java
proxy.newProxyInstance(userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(), invocationHandler)
```



# java集合框架

https://thinkwon.blog.csdn.net/article/details/104588551

## 继承图

![img](牛客面试题.assets/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc)

## TreeMap

在内部会对Key进行排序，使用`TreeMap`时，放入的Key必须实现**`Comparable`接口**。没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个**自定义排序Comparator的实现类**。



## HashMap

key 可以为null，如果再放null类型的key，会覆盖。



## 为什么使用红黑树

二叉搜索树可能会导致所有的节点都在一侧，进而导致查找时候的效率低下。

红黑树是一种不严格的平衡二叉树，它的查找效率其实相较于平衡二叉树差不多，但是插入时候会花费更多的时候。



### 为什么不一开始就是用红黑树

首先红黑树**占用的空间比普通的节点空间要多**，一开始本身数据量不多的时候，使用链表也可以很好的找到相应的节点。节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。



### 为啥不用跳表

跳表需要维护更多的多层链表，需要花费更多的内存。



### HashMap为啥每此扩容都是原来的2倍

向集合中添加元素时，会使用(n - 1) & hash的计算方法来得出该元素在集合中的位置，此时n-1的二进制全为1，此时和Hash与操作从数值上来讲其实等价于对length取模，这样与添加元素的hash值进行位运算时，能够充分的散列。



### put()方法流程

从代码看，put方法分为三种情况：

- table尚未初始化，对数据进行初始化
- table已经初始化，且通过hash算法找到下标所在的位置数据为空,直接将数据存放到指定位置
- table已经初始化，且通过hash算法找到下标所在的位置数据不为空，发生hash冲突（碰撞），发生碰撞后，会执行以下操作：
  - 判断插入的key如果等于当前位置的key的话，将 e 指向该键值对
  - 如果此时桶中数据类型为 treeNode，使用红黑树进行插入
  - 如果是链表，则进行循环判断， 如果链表中包含该节点，跳出循环，如果链表中不包含该节点，则把该节点**插入到链表末尾**，同时，如果链表长度超过树化阈值（**TREEIFY_THRESHOLD = 8**）且table容量超过最小树化容量（MIN_TREEIFY_CAPACITY），则进行链表转红黑树
- 判断键值对数量是否大于阈值，大于的话则进行扩容操作

注：jdk8中使用尾插，避免jdk7中使用头插，两个线程同时扩容导致的成环问题。



### resize()方法

首先先判断当前table是否进行过初始化，如果没有进行过初始化，此处就解决了调用无参构造方法时候，threshold和initialCapacity 未初始化的问题，如果已经初始化过了，则进行扩容，容量为原来的二倍。另外注意的是，扩容的时候，老的位置只可能去两个地方，一个不变，另外是加当前位置值 + oldSize.

扩容后创建新的table，并对所有的数据进行遍历

- 如果新计算的位置数据为空，则直接插入
- 如果新计算的位置为链表，则通过hash算法重新计算下标，对链表进行分组
- 如果是红黑树，则需要进行拆分操作。如果**长度小于6的话，就把它变成链表**



## ConcurrentHashMap

key 和 value 不能为null。

在HashMap之中，我们可以很容易的通过contains方法来判断key或者value为null是否真的存在。 但是这个问题要是出现在ConurrentMaps中了，那么就可能会有问题了。试想一下，当我们首先从map中get某个key，由于map中这个key不存在，那么会返回null，这之后我们通过contains进行判断，此时如果有线程并发写入了一条value为null的值，那么contains的结果就为true。这样就会与真实的情况不一致了，这就是二义性。



+ 计算记录的key的hashCode，然后计算table的index位置，然后获取该index的值
+ 如果该位置还为null，说明该位置上还没有记录，则通过调用**casTabAt**方法来讲该新的记录插入到table的index位置上去
+ 通过**synchronized关键字对table的index位置加锁**，需要注意的是，当前线程只会锁住table的index位置，其他位置上没有锁住，所以此时其他线程可以安全的获得其他的table位置来进行操作。
+ 然后判断table的index位置上的第一个节点的hashCode值，如果hashCode值小于0，这个节点是红黑树的根节点，否则是链表。
+ 链表的节点数大于8，就将链表转化为红黑树。
+ 最后，添加计数，如果表太小且尚未调整大小，则开始调整。



## ArrayList底层(和LinkedList做区别)

**底层是Object数组**，动态数组。与java中的数组比，可以**容量可以动态增长**，适用于**查找多**的情况，默认数组长度为10。

扩容机制：int newCapacity = oldCapacity + (oldCapacity >> 1);

+ 在添加元素的时候，先判断**加入元素后的大小是否大于elementData.length**，如果**大于进行扩容。**
+ 将新容量更新为就**容量的1.5倍**
+ 如果**新容量还是小于需要的最小容量**，就把最小需要容量当作数组的新容量
+ 再检查新容量是否**超出了ArrayList所定义的最大容量**，如果大于就设置容量为Integer.MAX_VALUE

在集合的某位插入、删除对象的时间为O(1)，在其他位置增加或者删除元素，时间复杂度为O(n)，将后面元素的位置向后移一位或者向前移一位。

ArrayList有两个remove()重载方法

```java
remove(int index);
remove(Object o);

remove(1) // 是删除索引为1的元素
remove(new Integer(1)) // 则删除元素1
    
	// ArrayList在删除方法的时候，删除元素后，所有的元素都往前面移动了一位。
    // 使用下面的方法删除索引为偶数的元素就不会得到我们想要的结果
    for(int i=0;i<list.size();i++) {
        if(list.get(i)%2==0) {
            list.remove(i);
        }
	}
	// 如果删除索引为偶数的元素的话，
    for(int i=list.size()-1;i>=0;i--) {
        if(list.get(i)%2==0) {
            list.remove(i);
        }
    }

	// 在ArrayList使用迭代器的时候，如果直接使用ArrayList删除元素，下次使用迭代器对象的next方法时，就会保存，因为next方法会对操作集合的次数进行判断，如果对集合的操作次数modCount与生成迭代器时的操作次数 expectedModCount时不同，就会抛出异常。不过可以使用迭代器对象的删除方法，他会在删除完了之后，让expectedModCount 和 modCount的值保持一致。
```





## ArrayList 和 Vector 的区别

1. `Vector` 是 `List` 的古老实现类，底层使用**Object数组**存储，在**方法名称前加synchronized 来保证线程安全的**。
2. `ArrayList` 是 `List` 的主要实现类，底层使用**Object数组**存储，适用于频繁的查找工作，**线程不安全** ；



## ArrayList 为什么使用transient 修饰elementData

因为ArrayList中一般实际存储的元素个数是小于elementData数组的大小的，将整个elementData序列化会费一点效率去序列化那些没有用到的空间。



## LinkedList底层

LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。实现类List接口和Deque接口的**双端链表**，适用于**插入删除多的**情景，**不是线程安全**的。**内部私有类 Node**，保存了前驱节点，本节点的值，后继结点。所以LinkedList是**双向链表**，成员变量 **first 和 last 分别表示头结点和尾结点**。



## 线程安全的ArrayList：CopyOnWriteArrayList

在使用增删改的过程中都是用了 ReentrantLock ，保证某个阶段只有一个线程能够对它进行操作。CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过**创建底层数组的新副本**来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，**读和写使用不同的容器**。使用场景读多写少。



### 如何实现 Array 和 List 之间的转换？

- Array 转 List： Arrays. asList(array) ；
- List 转 Array：List 的 toArray() 方法。



## HashSet 的实现原理

HashSet 是基于 HashMap 实现的，HashSet的值存放于**HashMap的key上，HashMap的value统一为PRESENT**，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。


## 如何边遍历边移除 Collection 中的元素

使用Iterator对象的 remove 方法。不可以使用 list.remove(i) 方法。



# 多线程和 JUC

## java 线程间的同步

锁：synchronized，ReentrantLock；等待通知；Semaphore类；管道`PipedWriter`、 `PipedReader`、 `PipedOutputStream`、 `PipedInputStream`。其中，前面两个是基于字符的，后面两个是基于字节流的。



## 线程的生命周期

+ 初始状态(NEW)：尚未启动的线程的线程状态。
+ 运行状态(RUNNABLE)：通过线程的start()方法从初始状态转为运行状态，obejct 对象的notify()方法，LockSupport的unpark(Thread)方法从等待状态转运行状态。
+ 等待状态(WAITING)：Thread.join()，LockSupport的park()方法,Object.wait()方法从运行状态转为等待状态。
+ 超时等待(TIMED_WAITING)：
+ 阻塞(BLOCKED)：进入**synchronized方法**，或者代码块内。
+ 终止(TERMINATED)。

![在这里插入图片描述](牛客面试题.assets/2019112814395878.png)



## synchronized修饰静态和非静态方法的区别

Synchronized修饰静态方法，实际上是对**该类对象加锁**；

Synchronized修饰非静态方法，实际上是**对调用该方法的对象加锁**；

synchronized 加对象的字节码文件monitorenter指令和monitorexit指令，如果其对象还没有被其他对象获得，那么当前线程就会获取锁，否则线程就会被挂起。锁对象底层是有一个monitor对象，这个对象主要包括**拥有者**（即锁的拥有者），**存储处于wait状态的线程的队列**，**存储等待锁线程的队列**。监视器锁（monitor）是依赖于底层的操作系统的**Mutex Lock**来实现的，**mutex lock互斥锁**主要用于实现内核中的互斥访问功能，需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。所以jdk1.6之后就出现了偏向锁，轻量级锁和重量级锁。

**偏向锁**的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。

倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为**轻量级锁**的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁所适应的场景是**线程交替执行同步块**的场合，**如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。**

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为**自旋锁**的优化手段。这是基于**在大多数情况下，线程持有锁的时间都不会太长**，如果**直接挂起**操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要**从用户态转换到核心态**。在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：
1、保存 CPU 寄存器里原来用户态的指令位
2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。
3、跳转到内核态运行内核任务。
4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。
这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会**让当前想要获取锁的线程做几个空循环**(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，把轻量级锁升级为重量级锁了。



## 偏向锁，轻量级锁和重量级锁

![image-20210722174812215](牛客面试题.assets/image-20210722174812215.png)





## Java多线程实现的方式有四种

1. 继承Thread类，重写run方法。
2. 实现Runnable，重写run方法。**Runable没有返回值。**
3. 实现Callable的**call**方法。通过实现Callable和FutureTask创建线程，也可以通过线程池执行结果。**Callable有返回值。**
4. 线程池实现

 线程不可以start()两次，否则会报错。

**`Runnable` 接口** 不会返回结果或抛出检查异常，但是 **`Callable` 接口** 可以

```java
// FutureTask的构造函数，参数为Callable实例
public FutureTask(Callable<V> callable) {
    
}
```

使用Callable+FutureTask获取执行结果。

```java
public class Test {
    public static void main(String[] args) {
        //第一种方式
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(task);
        executor.submit(futureTask);
        executor.shutdown();
         
        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread
        /*Task task = new Task();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(task);
        Thread thread = new Thread(futureTask);
        thread.start();*/
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println("主线程在执行任务");
         
        try {
            System.out.println("task运行结果"+futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println("所有任务执行完毕");
    }
}
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("子线程在进行计算");
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i<100;i++)
            sum += i;
        return sum;
    }
}
```

Callable通过线程池执行结果。**submit提交到线程池的时候，返回Future对象，使用Future对象的get()方法获取结果。**

```java
public class Test {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future<Integer> result = executor.submit(task);
        executor.shutdown();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println("主线程在执行任务");
         
        try {
            System.out.println("task运行结果"+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println("所有任务执行完毕");
    }
}
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("子线程在进行计算");
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i<100;i++)
            sum += i;
        return sum;
    }
}
```



## sleep yield wait join的区别

join() 是用线程对象来调用，**当前运行线程调用另一个线程的join方法**，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。

wait()和notify()、notifyAll() 被Object对象调用，并且在synchronized代码块中调用。

sleep() ，Thread类的方法**会释放cpu资源，不释放锁资源**；wait()，**释放cpu资源，也释放锁资源**。

yield：**让出CPU调度，不会释放锁**，Thread类的方法。执行yield()的线程有可能在进入**到可执行状态后**马上又被执行。



## Java内存模型( JMM )和synchorized、volatile

Java内存模型中规定**所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问**，但**线程对变量的操作(读取赋值等)必须在工作内存中进行**，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝

**synchorized** 块内使用到的变量从线程的工作内存中清除，这样就会**直接去主内存中获取，不会从线程的工作内存获取**。退出synchronized 块会**将本地内存中修改的共享变量刷新到主内存。**



**volatile关键字**：**不保证原子性**。写入变量会直接把值刷新回主内存。当其他线程**读取该变量的时候，会从主存中重新获取最新值，并不会访问当前线程工作内存中的值。**同时也会**禁止指令重排**：当程序执行到 volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。



## ThreadLocal

Thread 里面都有一个 ThreadLocalMap，而 ThreadLocalMap 中真正承载数据的是一个 Entry 数组，**Entry 的 Key 是 threadlocal 对象的弱引用**。

将 threadlocal 变量置为 null，threadlocal 对象下一次 GC 会被回收，那么 Entry 中的与之关联的弱引用 key 就会变成 null，如果此时当前线程还在运行，那么 Entry 中的 key 为 null 的 Value 对象并不会被回收（存在强引用），这就发生了内存泄漏。如果使用的是线程池呢，线程跑完任务以后放回线程池（线程没有销毁，不会被回收），Value 会一直存在，这就发生了内存泄漏。



### 为什么ThreadLocalMap的key使用弱引用

如果 key 是强引用，ThreadLocal 对象被回收了，但是 ThreadLocalMap 还持有ThreadLocal 的强引用，线程中的 ThreadLocalMap 对象，如果没有手动删除，还是不会被回收，导致 Entry 内存泄漏，由于ThreadLocal 对象被回收，它对应的 Entry 已经拿不到了，但如果是弱引用此时就会被回收掉。



## 线程池

五种状态：

+ RUNNING
+ SHUTDOWN
+ STOP
+ TIDYING
+ TERMINATED

### execute()方法和 submit()方法的区别

1. `execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
2. `submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功。并且可以通过 `Future` 的 `get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成，而使用 `get（long timeout，TimeUnit unit）`方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

### 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue<Runnable> workQueue,
                      ThreadFactory threadFactory,
                      RejectedExecutionHandler handler) 
```

- `corePoolSize` : 核心线程数线程数定义了最小可以同时运行的线程数量。
- `maximumPoolSize` : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
- `keepAliveTime`:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
- `unit` : `keepAliveTime` 参数的时间单位。
- `threadFactory` :executor 创建新线程的时候会用到。
- `handler` :饱和策略。关于饱和策略下面单独介绍一下。

饱和策略：

+ `ThreadPoolExecutor.AbortPolicy`： 抛出 `RejectedExecutionException`来拒绝新任务的处理。**抛异常。**
+ `ThreadPoolExecutor.CallerRunsPolicy`： **调用执行自己的线程运行任务**，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
+ `ThreadPoolExecutor.DiscardPolicy`： **直接丢弃掉新任务。**
+ `ThreadPoolExecutor.DiscardOldestPolicy`： **将丢弃最早的未处理的任务请求。**



### execute源码

主要涉及三步：

1. 判断当前线程池中的任务是否小于corePoolSize，如果小于，调用addWorker(command, true)函数新建一个线程并将任务添加到线程中，启动线程。

   1. 传入的第二个参数 true 表示使用corePoolSize作为当前线程池线程参数的最大个数。
   2. 创建new Worker对象,**传入的参数就是任务**，创建worker对象的时候，他的**构造方法里面会使用线程工厂新建一个线程出来**,线程传入参数就是这个worker对象，因为worker对象实现了 runnable 接口，赋给 Worker 的 thread 属性。
   3. 

2. 如果当前执行的任务数量大于corePoolSize，如果线程是RUNNING状态，提交到阻塞队列中，如果**阻塞队列满了**，就继续调用 addWorker(command, false) 添加线程调用任务，不过这次线程池钟线程的最大参数是maxnumPoolSize了。

3. 如果**无法创建线程执行任务，阻塞队列也满了，就只能执行拒绝策略**了。

4. worker每次run之后，就设置自己的firstWorker为空，**如果firstWorker为空，他就会从阻塞队列中拿任务进行run。**

   使用try catch捕获异常**并直接抛出**异常的。

```java
public void execute(Runnable command) {
    // 如果任务为null，则抛出异常。
    if (command == null)
        throw new NullPointerException();
    // ctl 中保存的线程池当前的一些状态信息
    int c = ctl.get();

    //  下面会涉及到 3 步 操作
    // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize
    // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里
    // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。
        if (!isRunning(recheck) && remove(command))
            reject(command);
            // 如果当前线程池为空就新创建一个线程并执行。
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
    //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。
    else if (!addWorker(command, false))
        reject(command);
}

private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
        	// 创建一个新的工作者。
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // workers 是一个hashSet 正在运行的worker会保存在这里。
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                	// 线程运行
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
				// Worker中run的一部分
    			// 每个线程run完之后判断自身是不是有任务，或者阻塞队列中是不是有线程可以拿出来跑。
				// 注意一下getTask()的返回时机，在一个无限制for循环中，从workQueue阻塞队列中取出待执行的任务，能正常获取到则将任务返回，否则持续循环获取，直至获取成功，除非线程池状态进入stopping 或者 workQueue为空 ，或者 工作者线程数超过了最大池大小maximumPoolSize ，或者 获取任务超时 ，getTask()方法才会跳出for循环并返回。

    			while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
    
```



### 线程池异常





## Atomic原子类

### AtomicLong、AtomicInteger、AtomicBoolean原理类似。

使用volatile 关键字修饰 value，设置新值，加一减一都是通过Unsafe的方法来设置的。



### LongAdder

在java.util.concurrent.atomic 包下。多个线程在竞争一个 cell 原子变量失败可以转而竞争其他的 cell 变量 ，它不可以设置值，只提供加减以及双倍操作。获取当前的值时，把所有Cell数组变量的value值加起来，再加上base返回。



### CAS会产生ABA问题，AtomicStampedReference类登场

AtomicStampedReference 有个静态内部类 Pair，保存了时间戳和具体的对象。对象值和时间戳都要满足条件，写入才会成功。

下面分别是

```java
AtomicInteger ：public final boolean compareAndSet(int expect, int update) 
AtomicStampedReference<V> :public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp)
```





```java
private static class Pair<T> {
        final T reference;
        final int stamp;
        ''''''
    }
```



## ReenTrantLock

AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus

ReentrantLock的**基本实现**可以概括为：先通过CAS尝试将state从0变为1获取锁。如果失败，再进入tryacquire方法使用CAS操作尝试将state从0变为1获取锁如果失败，判断是否是当前线程站占有锁，可重入次数变为state + 1，结束。如果此时已经有其他线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：

非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；

公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。



公平锁还是非公平锁具体看 sync 的实现是ReenTrantLock 还是 NonfairSync 还是 FairSync ,这两个类都继承 Sync , Sync继承AQS。**一开始 AQS 的 state 值为0，表示锁没有被任何线程持有**，当第一个线程获得锁的时候，就让 state 为 1，当前线程再次获得锁的话，state 为2，也就是ReenTrantLock是可重入的。

### 非公平锁的lock方法

一开始 AQS 的 state 值为 0 ，就使用CAS操作当前state状态值为 1，设置当前的exclusiveOwnerThread 为当前线程。如果 state 不为0，就继续判断当前 state 是否为0，或者当前线程是否是锁持有者，是的话，state 状态再继续加。否则就加入到队列中，挂起。



### unlock方法

state状态，-1。如果state状态为0，就在阻塞队列中唤醒一个线程。



### 公平和非公平是如何体现的

在尝试获取锁的过程中判断阻塞队列**如果为空，或者如果阻塞队列第一个元素的线程为当前线程，那么就可以获得锁**。**非公平性直接使用CAS操作将 state 设置为1**



## ReenTrantReadWriteLock

ReenTrantReadWriteLock内部的 state 的高16位表示读状态，获取读锁的次数；低16位表示写锁的可重入次数。

写锁独占，某个时刻只有一个线程可以获取该锁。tryAcquire先判断state是否为0：

+ 不为0时，如果**有线程获取读锁或者当前线程不是锁拥有者，获取锁失败**。否则，可重入次数+1
+ 为0时，具体看是公平锁还是非公平锁。公平锁**如果阻塞队列为空，或者如果阻塞队列第一个元素的线程为当前线程，那么就可以获得锁**，非公平就可以直接获得锁。获得锁也就是使用CAS设置状态。

读锁的获取：

+ 如果写锁被其他线程获取，就获取失败。
+ 判断阻塞队列的第一个元素**是不是等待写锁的线程**(**非公平，公平的话，判断有没有其他的线程在等待**)，如果不是且当前读锁的线程没有到达最大值，执行CAS操作将AQS状态值+1
+ 这里是一个无限循环：如果读锁CAS 失败或者应该等待写锁(**非公平，公平的话，判断有没有其他的线程在等待**)，但是是冲入写锁的需要处理，否则就要加到阻塞队列里面去。



## CopyOnWriteArrayList原理

和他的名字一样，写时复制的容器。当**我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。**

CopyOnWriteArrayList允许并发读，**读操作无锁**。内部有一个ReentrantLock锁，写的时候就加锁，复制了一个快照，在快照上面添加，如果此时有其他线程在读的话，访问的是老的快照，也没问题的，只不过产生了弱一致性问题。



## ConcurrentLinkedQueue 

内部使用**单向**链表实现，有两个 volatile 类型的 Node 节点分别表示队列的首尾节点



## LinkedBlockingQueue 可有界或无界

有界的时候，可以指定它的大小，如果不指定的话，容量等于Integer.MAX_VALUE，如果有大量的任务，会消耗大量内存。它使用**单向链表**实现，有**两个Node分别表示首尾节点**，**原子变量count**，记录队列的元素。**两个**ReentrantLock的实例分别**控制元素入队和出队**的原子性（表明**入队操作和出队操作可以同时发生**）。这两个ReentrantLock的条件变量分别创建条件队列，用来阻塞进队时队列已经满，出队时队列为空的线程。



## ArrayBlockingQueue 有界

ArrayBlockingQueue 一旦创建，**容量不能改变**，使用 **Object 数组**保存队列元素。两个变量保存**入队元素和出队元素下标**。**一个独占锁**保证出入队的原子性（**表示只有一个线程可以进行入队操作和出队操作**）。**两个条件队列**用来阻塞进队时队列已经满，出队时队列为空的线程。默认情况下不能保证线程访问队列的公平性，如果需要的话，构造方法的第二个参数传入true。



# 计算机网络

## OSI七层模型

+ 物理层：传输比特0和1。 bit
+ 数据链路层：控制网络层和物理层的通信。 帧
+ 网络层：建立主机之间的连接，ip寻址和路由选择。**ARP，DHCP，ICMP协议**。 分组，数据包。
+ 传输层：建立端口之间的连接。**TCP和UDP**。 
+ 会话层：**负责建立和断开通信连接**（数据流动的逻辑通路)，以及**数据的分割等数据传输相关的管理**。
+ 表示层：将**应用处理的信息转换为适合网络传输的格式**，或将来自下一层的数据转换为上层能够处理的格式。因此它主要**负责数据格式的转换**。
+ 应用层：为应用程序**提供服务**并规定应用程序中通信相关的细节。 （**HTTP,DNS,FTP**）



## HTTP

### 常见的请求头

![image-20210802145513697](牛客面试题.assets/image-20210802145513697.png)



### 状态码

1开头：需要请求者继续执行操作。 100 继续。客户端应该继续请求

2开头：成功。**200 OK**；204：该状态码代表服务器接收的请求已成功处理，但在**返回的响应报文中不含实体**的主体部分；该状态码表示客户端进行了范围请求，而服务器成功执行了范围请求。

3开头：重定向。需要进一步操作。301：**永久性**重定向，该状态码表示请求的资源已被分配了新的URI；302： **临时性**重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问，此时的URI将来还有可能发生改变。

4开头：这些状态代码表示**请求可能出错**，妨碍了服务器的处理。400：请求报文中存在语法错误；401：错误请求。401：第一次表示要求身份验证，第二次表示身份验证失败；403：服务器拒绝请求，可能是没有访问权限；404：未找到。405：方法禁用。

5开头：服务器内部错误。500：服务器遇到错误；503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



## HTTP1.0 1.1 2.0

### http1.0

HTTP 1.0规定**浏览器与服务器只保持短暂的连接**，浏览器的**每次请求**都需要与服务器**建立一个TCP连接**，服务器完成**请求处理后立即断开TCP连接**。访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，**每次请求和响应都需要建立一个单独的连接**，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程。



### http 1.1

**长链接**：为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持**持久连接**（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，**但每个单独的网页文件的请求和应答仍然需要使用各自的连接。**

client和server都是默认对方支持长链接的，为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明**connection的值为close**。如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。

**管道传输**：采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是**服务器还是按照顺序回应**，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「**队头堵塞**」。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。

HTTP1.1的**缺陷**：

+ **请求头或者响应头未经压缩就发送**，首部信息越多延迟越大。
+ 每次互相发送**相同的首部造成的浪费**较多。
+ 管道机制允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为“**队头阻塞**”
+ 没有请求优先级控制；
+ 请求只能从客户端开始，服务器只能被动响应。



### HTTP 2.0

**头部压缩：**HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的分**。

这就是所谓的 `HPACK` 算法：在客户端和服务器**同时维护一张头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送**索引号**，这样就**提高速度**了。

**二进制帧**：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式。**头信息和数据体都是二进制**，并且统称为帧（frame）：**在 HTTP 2.0 中，它把数据报的两大部分分成了 `header frame` 和 `data frame`。也就是**头部帧**和**数据体帧**。增加了数据传输的效率。

**流**：HTTP/2 将**每个请求或回应的所有数据包，称为一个数据流**（stream）。每个数据流都有一个独一无二的**编号**。数据包发送的时候，**都必须标记数据流ID，用来区分它属于哪个数据流**。

+ 双向性：同一个流内，可**同时发送和接受数据**。
+ 有序性：**流中被传输的数据就是`二进制帧`** 。帧在流上的被发送与被接收都是按照顺序进行的。
+ 并行性：流中的 `二进制帧` 都是被并行传输的，无需按顺序等待。但却不会引起数据混乱，因为每个帧都有顺序标号。它们最终会被按照顺序标号来合并。

**多路复用**：HTTP/2 把 HTTP 协议通信的**基本单位缩小为一个一个的帧**，这些帧对应着逻辑**流**中的消息。并行地在同一个 TCP 连接上双向交换消息。HTTP/2 是可以在**一个连接中并发多个请求或回应，而不用按照顺序一一对应**。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现**「队头阻塞」**问题，**降低了延迟，大幅度提高了连接的利用率**。

**服务器推送**：HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。



## GET 和 POST 的区别

GET 是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。

而 POST 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

GET请求参数是通过URL传递的，多个参数以&连接，POST请求放在request body中。

GET请求参数会**被完整保留在浏览历史记录里**，而POST中的**参数不会被保留**。



## TCP和UDP的区别

![image-20210705192546250](牛客面试题.assets/image-20210705192546250.png)

1. TCP是**面向连接**的，建立连接时需要经过**三次握手**，释放连接时要**四次挥手**。UDP是无连接的。
2. TCP**可靠**的，**确认序列号，序列号，超时重传**，保证可靠性。而UDP是不可靠的。
3. TCP主要的头信息：源端口号，目的端口号，ACK，FIN，SYN，确认序列号，序列号，校验和（校验和UDP也有）。UDP源端口号，目的端口号，数据包长度，校验和。TCP头部开销多，UDP头部开销少。
4. TCP适用于可靠性的传输，比如**文件传输**，UDP适用于实时应用，（**电话，视频**）。

**面向报文和面向字节流的区别：**

**面向报文**的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，**应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。**
**面向字节流**的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。



## TCP的可靠传输、流量控制、拥塞控制

可靠传输：序号、确认、超时重传机制、冗余ACK（当发生方收到同一个报文的三个冗余ACK时，就认为这这个报文段已经丢失）。

流量控制：滑动窗口。接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口大小rwnd，在TCP报文段的“窗口”字段值。根据当前网络中的拥塞状况确定cwnd。**取rwnd和cwnd的较小值为发送端的实际值**

拥塞控制：慢开始、拥塞避免。

慢开始：初始化拥塞窗口为 1 个最大报文段长度，每经过一次传输拥塞窗口就会加倍，窗口大小大于阈值使用拥塞避免算法。

拥塞避免：每经过一个往返时延，就增加一个报文段长度。当出现一次超时，**阈值设为当前窗口值的一半，同时，拥塞窗口设置为1，然后慢开始**

快恢复是对拥塞避免的修改：出现超时的时候，**阈值设为当前窗口的一半，拥塞窗口设置为当前阈值，每经过一个往返时延，就增加一个报文段长度**。



## TCP的黏包拆包问题

假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：

**第一种情况：**接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。



![img](牛客面试题.assets/170b28767c72efef~tplv-t2oaga2asx-watermark.awebp)



**第二种情况：**接收端只收到一个数据包，由于TCP是不会出现丢包的，所以**这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包**。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。



![img](牛客面试题.assets/170b2877abc959d3~tplv-t2oaga2asx-watermark.awebp)



**第三种情况：**这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是**多出来一块**，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。



![img](牛客面试题.assets/170b2876754df278~tplv-t2oaga2asx-watermark.awebp)





![img](牛客面试题.assets/170b28766f2164b5~tplv-t2oaga2asx-watermark.awebp)



### 为什么会发生TCP粘包、拆包？

- 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
- 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
- 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

### 粘包、拆包解决办法

1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。



## 数字签名和数字证书

手下打开浏览器输入: https://某宝.com，敲回车键，接下来发生一连串的连锁反应。
**第一步**:浏览器与某宝建立TCP连接
**第二步**:服务器会弹出一个页面提醒安装数字证书，如果不安装，接下来一切都不会顺利进行
**第三步**:浏览器需要认证某宝是真实的服务器(不是山寨的)，服务器发来了自己的数字证书。
插—句:某宝的**数字证书**从哪里来?

某宝自己的认证中心简称CA(Certificate Authority)，CA给某宝颁发了一个证书，这个证书有:签发者、证书用途、**某宝的公钥**、某宝的加密算法、某宝用的HASH算法、证书的到期时间等。

CA为了避免传输过程中其他人篡改这些证书，把以上内容做一次HASH，得到一个固定长度再用CA的私钥加密，得到了数字签名，附在证书的末尾，传输给某宝

**第四步**:浏览器接到某宝的数字证书，**从第二步得到的CA公钥值**，可以解密数字证书末尾的数字签名(CA私钥加密，可以用CA公钥解密，此为非对称加密)，**得到原始的HASHs**。然后自己也按照证书的HASH算法，**自己也计算一个HASHc，如果HASHc== HASHs，则认证通过**，否则认证失败。假设认证成功，否则故事无法编下去了...

**第五步**:双方会运行Diffie Hellman算法，简称DH算法。通俗地说:双方会协商一个master-key，这个master-key 不会在网络上传输、交换，它们独立计算出来的，其值是相同的，只有它们自己双方知道，任何第三方不会知道，俗称的天不知，地不知，你知，我知。

第六步：双方交换数组



## HTTP和HTTPS的区别

超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以**明文方式发送内容**，不提供任何方式的数据加密，HTTP协议**不适合传输一些敏感信息**，比如：信用卡号、密码等支付信息。

为了解决这个缺陷，需要使用HTTPS，HTTPS协议是由**SSL+HTTP**协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS的**加密过程**：要提到数字证书，用数字证书的机构公钥判断证书是否合法。TLS可以花费两个RTT。

1. 客户端向服务端发起第一次**握手请求**，此时会发送**第一个随机数**，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 当服务端收到客户端的请求后，会确认 TLS 版本号是否⽀持，和从密码套件列表中选择⼀个密码套件，以及⽣成**第二个随机数** 
3. 服务端将自己的公钥发给数字证书认证机构，**数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名**，并给服务器颁发公钥证书。
4. 服务端将证书发给客户端。
5. 客户端利用**数字认证机构的公钥，验证数字证书的合法性，同时获取服务器的公钥**，确认服务器公开密钥的真实性。
6. 客户端就会⽣成⼀个**第三个随机数** ，⽤服务器的 RSA **公钥**加密该随机数  ，发给服务端。
7. 服务端收到后**利用私钥解密信息，获得客户端发来的对称密钥**。
8. 通信双方可用这三次的所忌讳，生成对称秘钥，**对称密钥来加密解密信息**。

**为什么要使用混合加密？**

对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是**缺陷在于对于密钥的管理和分发上比较困难，不是非常安全**。



## 三次握手（2，4，3）

- 第一次握手：客户端向服务端发起建立连接请求，客户端会**随机生成一个起始序列号x**，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
- 第二次握手：服务端在收到客户端发来的报文后，会**随机生成一个服务端的起始序列号y**，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。

![image-20210710142049014](牛客面试题.assets/image-20210710142049014.png)

两次是否可以？

+ 假设建立TCP连接仅需要两次握手，那么如果第二次握手时，**服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接**，并且**可能服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源**。
+ 如果服务端接收到了一个**早已失效的来自客户端的连接请求报文**，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次**TCP连接没有意义并且浪费了资源。**



### Syn Flood攻击

如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，**从而消耗大量的服务器资源**，同时也使得正常的连接请求无法被相应。

+ 回收最早的半开TCP连接
+ syn队列满的时候，在TCP服务器，接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值，计算一个消息摘要mac。mac = MAC(A, k)，MAC是密码学中的一个消息认证码函数，也就是满足某种安全性质的**带密钥的hash函数**，它能够提供cookie计算中需要的安全性。这个cookie作为将要返回的SYN ACK包的初始序列号。当客户端返回一个ACK包时，**根据包头信息计算cookie**，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，**则是一个正常连接，然后，分配资源，建立连接。**




## 四次挥手（2，3，4，3）

- 第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位**FIN=1，序列号seq=u**。此时客户端只能接收数据，不能向服务端发送数据。
- 第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含**标志位ACK=1，序列号seq=v，确认号ack=u+1**。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。**此时服务器端出于CLOSE-WAIT阶段。**
- 第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
- 第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。**此时客户机处于TIME-WAIT阶段**。

![image-20210710142709463](牛客面试题.assets/image-20210710142709463.png)

为什么关闭的时候是四次而不是三次？

服务端**通常需要等待完成数据的发送和处理**，所以服务端的 ACK 和 FIN ⼀般都会分开发
送，从⽽⽐三次握⼿导致多了⼀次。 



**为什么 TIME_WAIT 等待的时间是 2MSL？**  

第四次挥手的报文丢失，服务端没收到确认ack报文**就会重发第三次挥手的报文**，这样报文**一去一回最长时间就是2MSL**（MSL是报文最大生存时间，超过这个时间报文就会被丢掉），所以需要等这么长时间来确认服务端确实已经收到了。



### 为什么需要TIME_WAIT状态

1. 有**相同端⼝的 TCP 连接被复⽤**后，**上个TCP连接中延迟的报文抵达了客户端**，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题  
2. TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭。四次挥⼿的**最后⼀个 ACK 报⽂如果在⽹络中被丢失了**，此时如果客户端 TIME
   WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么**服务端则会⼀直处在 LASE_ACK 状态**  



## 如果已经建立了连接，客户端突然出现故障怎么办

TCP 有一个机制是**保活机制**。这个机制的原理是这样的：

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。2 ⼩时内如果没有任何连接相关的活动，则会启动保活机制，表示每次检测间隔 75 秒  ，检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。在 Linux 系统中，最少需要经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死亡」连接。  



## 当输入网址后，到网页显示，其间发生了什么

+ **解析URL**，解析完成之后需要**查询服务器域名对于的 IP 地址**
+ 通过**DNS**查询服务器域名对应的IP地址
+ （把 HTTP 的传输工作交给操作系统中的**协议栈**。）通过**TCP连接**，设置源端口和目的端口，包的序号，确认号，状态位，窗口大小。再建立连接之前要建立三次握手，连接释放的时候要进行三次挥手。如果HTTP请求消息比较长，超过了 `MSS`（除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度） ，这时 TCP 就需要把 HTTP 的数据拆解一块块的数据发送，而不是一次性发送所有数据。![image-20210803094910157](牛客面试题.assets/image-20210803094910157.png)建立完连接之后就会生成TCP报文。至此，HTTP数据前面就添加了TCP的头部信息。
+ TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托网络层的 IP 协议将数据封装成**网络包**发送给通信对象。添上相应的**源地址IP和目标地址IP**。此时，HTTP数据前面就添加了TCP的头部信息和IP的头部信息
+ 还需要在 IP 头部的前面加上 **MAC 头部**。可以通过 ARP 协议查找到MAC地址。此时，HTTP数据前面就添加了 TCP 的头部信息、IP 的头部信息和 MAC 头部信息。
+ 通过交换机和路由器发送到服务器。



## ping的工作原理

ping的话是通过ICMP协议工作的。`ICMP` 主要的功能包括：确认 IP 包**是否成功送达目标地址**、报告发送过程中 **IP 包被废弃的原因**等。在 `IP` 通信中如果某个 `IP` 包因为某种原因未能达到目标地址，那么这个具体的原因将**由 ICMP 负责通知**。主机 `A` 向主机 `B` 发送了数据包，由于某种原因，途中的路由器 `2` 未能发现主机 `B` 的存在，这时，路由器 `2` 就会向主机 `A` 发送一个 `ICMP` 目标不可达数据包，说明发往主机 `B` 的包未能成功。 ICMP 的这种通知消息会使用 `IP` 进行发送。 

ICMP 的回送消息有**回送应答**和**回送响应**。**回送消息**用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，`ping` 命令就是利用这个消息实现的。



# 操作系统

## 用户态和核心态

CPU为了判断当前用户是否可以执行特权指令执行分为两种用户状态：用户态和核心态。使用**程序状态寄存器（PSW）**中的某位标志位表示当前处理器处于什么状态。

用户态：运行用户自编程序，只能执行非特权指令。

核心态：运行操作系统程序。可以执行**特权指令**。

特权指令：不允许用户程序直接使用的指令。比如：**IO指令，中断指令，内存清零。**

内核程序：既可以执行**特权指令和非特权指令**，只可以运行在**核心态**。

应用程序：只能执行**非特权指令**，运行在**用户态**。

通过**中断**可以使用户态进入核心态，并且中断是**唯一途径**。比如IO操作完成，用户程序进行系统调用。



## 进程和线程

+ 进程是**资源分配**的基本单位，线程是cpu**调度**的基本单位;一个进程中可以有多个线程，它们共享进程资源；
+ 进程是资源分配的基本单位，但是线程不拥有资源，**线程可以访问隶属进程的资源**。
+ 进程的开销更大，线程的开销小。创建或撤销进程时，系统都要为之**分配或回收资源，如内存空间、I/O设备等**，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前进程CPU的保存及新调度进程CPU环境的设置，而**线程切换时只需保存和设置少量寄存器内容，开销很小。**
+ 线程间可以通过直接读写同一进程中的数据进行通信

**进程切换和线程切换**：线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。

线程分为用户线程和内核线程。

⽤户线程（User Thread） ：在用户空间实现的线程，不是由内核管理的线程，是**用户态的线程库来完成线程的管理，不需要从内核态转为核心态；**
内核线程（Kernel Thread） ：在内核中实现的线程，是**由内核管理的线程**，内核线程是由操作系统管理的，线程对应的 TCB ⾃然是放在操作系统⾥的，这样**线程的创建、终止和管理都是由操作系统负责。**  
java中的线程对应操作系统中的**内核级进程**（LWP），它是操作系统支持的**用户线程**，LWP 只能由内核管理并像普通进程⼀样被调度， Linux 内核是支持 LWP 的典型例⼦  



## 进程的PCB

### 进程的描述信息

进程标识符：**标识各个进程**，每个进程都有⼀个并且唯⼀的标识符；
用户标识符：**进程归属的用户**，用户标识符主要为共享和保护服务。

### 进程控制和管理信息

进程当前状态，如 new、 ready、 running、 waiting 或 blocked 等；
进程优先级：进程抢占 CPU 时的优先级

### 资源分配清单

有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使⽤的 I/O 设备信息。  

### cpu相关信息

CPU 中各个寄存器的值，当进程被切换时， **CPU 的状态信息都会被保存在相应的 PCB 中，以便进程**
**重新执行时，能从断点处继续执行**



### PCB的组织方式

通过链表的⽅式进行组织，把具有相同状态的进程链在⼀起，组成各种队列  

将所有处于就绪状态的进程链在⼀起，称为**就绪队列**；
把所有**因等待某事件⽽处于等待状态的进程链在⼀起就组成各种阻塞队列**；
另外，对于运行队列在单核 CPU 系统中则只有⼀个运行指针了，因为单核 CPU 在某个时间，只能运行⼀个程序。  



## 进程的内存结构

栈：系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量、实参和返回值。

堆：为变量进行内存分配的一块区域。



## 进程上下文切换

首先，**进程是由内核来管理和调度的，进程的切换只能发生在内核态**。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等**用户空间的资源**，还包括了内核堆栈、寄存器等**内核空间的状态**。所以进程上下文切换，**在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新当前加载进程的虚拟内存和用户栈**。

通常，**会把交换的信息保存在进程的 PCB**，当要运⾏另外⼀个进程的时候，我们需要从这个进程的 PCB
取出上下⽂，然后恢复到 CPU 中，这使得这个进程可以继续执行。



## 线程上下文切换

线程包括用户线程和内核线程。

⽤户线程是基于⽤户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库⾥⾯来实现的，对于操作系统⽽⾔是看不到这个 TCB 的，它只能看到整个进程的 PCB。
所以， ⽤户线程的整个线程管理和调度，操作系统是不直接参与的，⽽是由⽤户级线程库函数来完成线程的管理，包括线程的创建、终⽌、同步和调度等。  
**优点：**每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（**PC、栈指针、寄存器**）， TCB 由⽤户级线程库函数来维护，可⽤于不⽀持线程技术的操作系统；
⽤户线程的切换也是由线程库函数来完成的，⽆需⽤户态与内核态的切换，所以速度特别快；
**缺点：**  

+ 由于操作系统不参与线程的调度，如果⼀个线程发起了系统调⽤⽽阻塞，那进程所包含的⽤户线程都不能执行了。  
+ 当**⼀个线程开始运行后，除⾮它主动地交出 CPU 的使⽤权，否则它所在的进程当中的其他线程⽆法运⾏**，因为**用户态的线程没法打断当前运行中的线程，它没有这个特权**，只有操作系统才有，但是⽤户线程不是由操作系统管理的。  
+ 由于时间⽚分配给进程，故与其他进程⽐，**在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐较慢；**  



## 进程的五种状态

运行：该时刻进程占⽤ CPU  。

就绪：由于其他进程处于运行状态而暂时停止运行。

阻塞：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）而暂时停止运行。这时，即使给它CPU控制权，它也无法执行

创建、结束状态。

![image-20210813150739525](牛客面试题.assets/image-20210813150739525.png)

NULL -> 创建状态：⼀个新进程被创建时的第⼀个状态；
创建状态 -> 就绪状态：当进程被创建完成并初始化后，⼀切就绪准备运⾏时，变为就绪状态，这个
过程是很快的；
就绪态 -> 运⾏状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运⾏
该进程；
运⾏状态 -> 结束状态：当进程已经运⾏完成或出错时，会被操作系统作结束状态处理；
运⾏状态 -> 就绪状态：处于运⾏状态的进程在运⾏过程中，由于分配给它的运⾏时间⽚⽤完，操作
系统会把该进程变为就绪态，接着从就绪态选中另外⼀个进程运⾏；
运⾏状态 -> 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
阻塞状态 -> 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；
**如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内**
**存空间是有限的，被阻塞状态的进程占用着物理内存就⼀种浪费物理内存的行为。**
所以，在虚拟内存管理的操作系统中，通常会**把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次**
**运行的时候，再从硬盘换入到物理内存。**  



那么，就需要⼀个新的状态，来**描述进程没有占用实际的物理内存空间的情况**，这个状态就是挂起状态。
这跟阻塞状态是不⼀样，阻塞状态是等待某个事件的返回。
另外，挂起状态可以分为两种：
阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏；  



## CPU调度

每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行，调度程序从内存中选择一个能够执行的进程，并为之分配CPU。



### 调度算法

先来先服务调度算法：先到的先调度，如果长作业先到，后面的短作业就会等待很长时间。

短作业优先调度算法：从后备队列中选出一个或若干个运行时间最短的作业，将他们调入内存运行。**长作业可能会处于饥饿状态**。

优先级调度算法：从后备队列中选出一个或若干个优先级最高的作业，将他们调入内存运行。这里可以根据是否可抢占可分为非剥夺式抢占策略和剥夺式抢占策略， 还可以根据创建后进程的优先级是否可以改变分为静态优先级和动态优先级。

高响应比优先调度算法：对先来先服务和短作业优先的综合平衡，响应比为（等待时间 + 要求服务时间）/ 要求服务时间，先计算后备队列中每个作业的响应比，从中选取响应比最高的作业投入运行。

时间片轮转法：系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中的第一个进程执行。

多级反馈队列调度算法：时间片轮转法和优先级调度算法的综合。**设置了多个不同优先级的就绪队列，并赋予各个队列大小不同的时间片，使优先级越高的时间片越小**；新就绪的进程总是进入最高优先级队列的队尾，并按 FCFS 原则等待调度；当轮到该进程执行时，若它能在规定的时间片内完成，便可准备撤离系统，否则将他转入第二级队列末尾，再同样按 FCFS 原则等待调度；如果它在第二级队列上运行一个时间片后仍未完成，再依次将它转入第三级队列，……；系统总是调度第一级队列中的进程执行，仅当第一级队列空时，才调度第二级上队列上的进程执行。以此类推，仅当第 1~（i - 1）级队列空时，才调度第 i 级队列上的程序执行





## 进程间通信

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**

1. **管道**：管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。用于父子进程或者兄弟进程之间。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。使用 | 就是匿名管道。
2. **有名管道**：为了克服管道只能用于亲缘关系的进程间通信，提出了有名管道。有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，**以有名管道的文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**。mkfifo myPipe 创建一个管道；echo "hello" > myPipe  将数据写进管道，然后这里就停住了；cat < myPipe  读取管道中的数据，另一端停住的终端命令也正常退出了。管道这种**通信方式效率低，不适合进程间频繁地交换数据**  。
3. 消息队列：管道不适合进程间频繁地交换数据，消息队列的通信模式就可以解决。⽐如， A 进程要给 B 进程发送消息， A 进程把数据放在对应的消息队列后就可以正常返回了， B 进程需要的时候再去读取数据就可以了。消息队列是保存在内核中的消息链表，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消息体（数据块），每个消息体都是固定⼤⼩的存储块 ，如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。  
   消息队列**⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在**，⽽前⾯提到的**匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁**。
   缺点：消息队列**不适合⽐较⼤数据的传输** ，消息队列通信过程中，**存在⽤户态与内核态之间的数据拷⻉开销**
4. 共享内存：消息队列的读取和写⼊的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这⼀问题。多个进程可以可以直接读写同一块内存空间，避免了用户态和内核态消息拷贝的过程。  
5. **信号：**进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。比如说： Ctrl+C产生**SIGINT**程序终止信号，程序退出信号。kill -9 pid 产生**SIGKILL**用户终止进程执行信号。 kill pid 产生 **SIGTERM** 结束进程信号。
6. 消息队列
7. 共享内存：多个进程可以可以直接读写同一块内存空间
8. 信号量：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步

为了获得共享资源，进程需要执行下列操作：
 （1）**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
 （2）**等待一个信号量**：该操作会测试这个信号量的值，**如果小于0，就阻塞**。也称为P操作。
 （3）**挂出一个信号量**：该操作将信号量的值加1，也称为V操作。

7. **套接字(socket)**：通过 TCP/IP 进行网络通信



## 多线程和多进程的优缺点

### 多线程

优点：

+ 一个进程中的多个线程，它们彼此之间使用相同的地址空间，**共享大部分数据**，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，**线程间彼此切换所需的时间也远远小于进程间切换所需要的时间**。
+ 同一进程下的线程之间共享数据空间
+ 一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改；

缺点：

+  一个线程的崩溃可能影响到整个程序的稳定性
+ 线程之间的**同步和加锁**控制比较麻烦；

## 多进程





## 逻辑地址和物理地址

逻辑地址也叫做相对地址，一段程序在运行前只知道某条指令的逻辑地址，相当于一种偏移量。物理地址就是内存中实际存在的地址。指令的物理地址可以通过物理地址加上这个偏移量就是这个这条指令实际存放的地址。



## 段表页表

内存的连续分配方式：固定分区会产生内存碎片，以及程序太大放不进去任何一个分区。动态的分区，又会导致外部碎片。为了解决这个问题，所以产生了内存的非连续分配方式。

### 页表

将程序和内存空间都划分为大小相等且固定的块，块相对较小。**页表**的作用是将实现页号到内存物理地址的转换。页表包括**页号和块号**，其中**页号是隐含的**。

如果页表全部放在内存中，存取一直指令要**访问两次内存**，第一次访问页面，第二次访问物理块号。设置一个高速缓冲存储器为**快表**，加快查找过程。一个进程可能会有很多的页表，**进程在一段时间内只需要访问某几个页面，就可以正常运行了，没有必要让这个页表都常驻内存。**如果将很多的页表同时加载到内存中很浪费空间，在进程执行的时候，先将二级页表调入内存，找到进程的以及页表，有点索引的感觉。

## 段表

将用户程序根据逻辑分为不同的段。短表包括，段号（**隐含**）、段长和内存中的地址。

### 段页式

作业的物理的地址线分为若干个段，每个段都有自己的段号，然后将段分成若干个大小固定的页。

段表包含段号（隐含）、页表的长度和页表的起止地址。**先通过段表查找到页表的起始地址，然后通过页表找出在内存中的地址。**



## 虚拟内存

虚拟内存的定义：将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序启动。在执行的过程中， 当所访问的信息不在内存中，由操作系统将所需要的部分调入内存，继续运行程序，当然此时也会讲暂时不适用的内容换出到外存上。

**请求分页管理方式：**除了**页号（隐含）**和块号之外，还有**状态位**表示是否已经调入内存，**访问字段**表示一段时间内被访问的次数或者本页已有多长时间没有被访问过了。**修改位**表示页面在调入内存后有没有被修改过，**外存地址**保存页面在外存上的地址。如果程序运行过程中，所访问的页面不在内存中，便产生一个缺页中断。

**页面置换算法：**

+ 最佳置换算法：以后永不使用或最长时间不使用的页面（无法预测）
+ 先进先出页面置换算法：**优先淘汰最早进入内存**的页面
+ 最近最久未使用（LRU）算法
+ 时钟（CLOCK）置换算法：给每页添加一个附加的使用位：首次装入内存时，使用位设置为1，当页被访问到的时候就把使用为设置为1，将候选被替换出的页面被扫描到的时候，如果为1设置为0，如果为1就把它替换出去。



## 页面置换算法

+ 最佳置换算法：选择的被淘汰页面将是**以后永不使用的，或者是在最长时间内不再被访问的页面**,这样可以保证获得最低的缺页率。人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而**该算法无法实现**。
+ 先进先出(FIFO)页面置换算法：**优先淘汰最早进入内存的页面**，亦即在内存中驻留时间最久的页面。
+ 最近最久未使用(LRU)页面置换算法：选择**最近最长时间未访问过的页面予以淘汰**，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。
+ 时钟(CLOCK)置换算法：页表项的访问位（access bit），当一个页面被装入内存时，把该位初始化为0，然后如果这个页被访问（读/写）时，硬件把它置为1。把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）；当发生一个缺页中断，考察指针所指向的最老的页面，若它的访问为为0，则立即淘汰。若访问为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。



## 操作系统层面的锁

问题应该就是临界区互斥有哪些方法：

### 软件方面

![image-20210729185240016](牛客面试题.assets/image-20210729185240016.png)

![image-20210729185304302](牛客面试题.assets/image-20210729185304302.png)

![image-20210729185325549](牛客面试题.assets/image-20210729185325549.png)



### 硬件方面



## IO多路复用

1. select :文件描述符数量有限，不能超过1024个。有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。有最大连接数的限制。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。用户给我的文件描述符需要拷贝的内核中
2. poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是**基于链表**来存储的。
3. epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**



# JVM

## new 一个对象的步骤

**验证是否是第一次使用该类**。如果没有（不是第一次使用），那必须先执行相应的类加载过程（class.forname()）。

接下来虚拟机将 **为新生的对象分配内存** ，两种方式：**指针碰撞，空闲列表**。

虚拟机需要将分配到的内存空间中的数据类型都 **初始化**

**对对象头进行必要的设置** ，例如这个对象是哪个类的实例（即所属类）、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。

 **调用对象的init()方法** ,根据传入的属性值给对象属性赋值。

在线程 **栈中新建对象引用** ，并指向堆中刚刚新建的对象实例



## 对象在堆内存中的内存布局

+ 对象头：锁状态标志位，无锁，偏向锁，轻量级锁，重量级锁。

  无锁情况保存的是**对象的哈希值，对象分代年龄**，锁标志位。

  偏向锁保存的是**线程ID**，对象分代年龄，锁标志位

  轻量级锁保存**栈中锁记录的指针**，锁标志位。

  重量级锁**保存互斥量（重量级锁的指针）**，锁标志位。

  GC标记，前面为空，锁标志位为11。

  **偏向锁：**偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

  当一个线程访问同步代码块并获取锁时，会在**Mark Word里存储锁偏向的线程ID**，在线程进入和退出同步块时**不再通过CAS操作来加锁和解锁**。

  偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，**线程不会主动释放偏向锁。**

  **轻量级锁：**是指当**锁是偏向锁的时候，被另外的线程所访问**，偏向锁就会升级为轻量级锁，其他线程会通过**自旋的形式尝试获取锁，不会阻塞**，从而提高性能。

  重量级锁：锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入**阻塞状态**。

+ 实例数据：**各种类型的字段内容**，包括从父类集成下来的字段。

+ 对齐填充：为了让**对象的起始地址是8的整数倍**



## JVM内存布局

线程**独有**：

​	程序计数器：是当前线程所执行的**字节码的行号指示器**。

​	虚拟机栈：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表（**存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型）、操作数栈（**保存计算过程的中间结果**，同时作为计算过程中变量临时的存储空间）、动态链接（**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**）、方法出口等信息。

​	本地方法栈：区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务。

线程**共享**：

​	堆：**几乎所有的对象实例在这里分配内存**，也是垃圾收集器进行垃圾收集的最重要的内存区域。

​	方法区：Class的信息。包括类信息、域信息、方法信息等。



## 堆是分配对象的唯一选择么？

对于**某些未逃逸对象可以直接在栈上分配**，由于该对象一定是局部的，所以栈上分配不会有问题。在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况。



## 类加载过程

加载、链接（验证，准备，解析）、初始化

+ 加载：一个类的全限定名获取定义此类的二进制字节流，**在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口
+ 验证：确保class文件中的字节流包含的信息，符合当前虚拟机的要求
+ 准备：为**类变量（static变量）**分配内存并且设置该类变量的默认初始值，即零值。**这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化**。
+ 解析：**将常量池内的符号引用转换为直接引用的过程**，事实上，解析器操作往往会伴随着 JVM 在执行完初始化之后再执行。
+ 初始化：初始化就是执行**类的构造器方法**`init`()的过程。换句话说，**只对static修饰的变量或语句进行初始化。**



## 双亲委派机制

启动（Bootstrap）类加载器是C++实现的。扩展（Extension）类加载器，它负责加载`<JAVA_HOME>/lib/ext`目录下或者由系统变量-Djava.ext.dir指定位路径中的类库

双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

如何打破双亲委派机制：

1、如果不想打破双亲委派模型，那么只需要重写**findClass**方法即可

2、如果想打破双亲委派模型，那么就重写整个**loadClass**方法

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    long t1 = System.nanoTime();
                    // 这边父类没加载到，就自己加载
                    c = findClass(name);
                }
                ...
            return c;
        }
    }
```





## 垃圾回收各种算法

标记阶段主要使用可达性分析算法，以**GCRoots为起点，搜索被跟对象集合所连接的对象**，未连接的对象是不可达的，意味着对象已经死亡。

GCRoots可以使哪些元素：**虚拟机栈中和本地方法栈中引用的对象，类静态属性的对象，常量引用的对象，被synchronized持有的对象，虚拟机内部的引用对象等。**

+ 标记清除算法：先使用可达性分析算法进行标记，清除没有被标记的对象。清除并不是真的置空，而是**把需要清除的对象地址保存在空闲列表**里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。缺点：会**产生大量不连续的内存碎片，要维护一个空闲列表**。如果**java堆中包含大量需要回收的对象，效率低。**
+ 复制算法：将**内存空间**分为两块，每次只使用其中一块，在垃圾回收时**将正在使用的内存中的存活对象复制到未被使用的内存块**中，之后**清除正在使用的内存块中的所有对象**。缺点：将可用内存缩小了一半。
+ 标记压缩算法：**第一阶段和标记清除算法一样**，从根节点开始标记所有被引用对象第二阶段**将所有的存活对象压缩到内存的一端，按顺序排放。**相当于标记清除算法完成之后，再进行一次碎片整理。缺点：效率低于标记清除算法，移动过程中，需要**全程暂停用户应用程序**。
+ 分代收集算法：把Java堆**分为新生代和老年代**，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。年轻代特点：区域相对老年代较小，**对象生命周期短、存活率低，回收频繁。**老年代特点：**区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。**



## 垃圾回收器

### 新生代垃圾回收期：都是使用复制算法

Serial 垃圾回收器：使用的是**复制**算法，在**新生代**进行垃圾回收。它只会使用**一个CPU（串行）或一条收集线程**去完成垃圾收集工作。**更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程。**



ParNew 垃圾回收器：ParNew其实就是**Serial的`多线程`版本**，除了使用多线程之外，其余参数和Serial一模一样。俗称：`并行垃圾回收器`，采用`复制算法`进行垃圾回收



ParallelGC 回收器：**java8默认的垃圾回收器**，ParallelGC使用**复制算法**回收垃圾，也是多线程的。就是**非常关注系统的吞吐量**，`吞吐量`=`代码运行时间`/(`代码运行时间`+`垃圾收集时间`)



### 老年代垃圾回收器



Serial Old 垃圾回收器：Serial  Old是Serial回收器的`老年代`回收器版本，它同样是一个**`单线程`**回收器。使用**标记-压缩算法**。一般配合serial 垃圾回收器。



Parallel Old垃圾回收器：老年代`Parallel Old`垃圾回收器也是一种**多线程**的回收器，和新生代的ParallelGC回收器一样，也是一种**关注吞吐量**的回收器，他使用了**`标记压缩算法`**进行实现。**jdk8默认Parallel Old垃圾回收器配合ParallelGC 回收器进行垃圾回收。**



CMS 垃圾回收器：垃圾收集算法采用**标记-清除**算法，并且也会"Stop-the-World"。关注的是**尽可能缩短垃圾收集时用户线程的停顿时间**。JDK14中已经删除了CMS垃圾回收器。

分为四个步骤：

+ 初始标记：**标记出GC Roots能直接关联到的对象**。**速度很快**，**会暂停用户线程**。
+ 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程**耗时较长**但是**不需要停顿用户线程**，可以与垃圾收集线程一起并发运行。
+ 重新标记：**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，停顿时间通常会比初始标记阶段稍长一些，并且也**会导致“Stop-the-World”**的发生
+ 并发清除：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。**由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的**

缺点：**会产生内存碎片**，**CMS收集器无法处理浮动垃圾。浮动垃圾：并发标记和并发清理阶段用户线程产生的垃圾。**



G1回收器（**延迟可控的情况下获得尽可能高的吞吐量**）：同时兼顾新生代和老年代。**将堆划分为一块块独立的 Region**。**G1中的新生代和老年代在内存区域中就不需要是连续的**。

G1垃圾回收器的记忆集**还记录谁指向我**，key为其他region的起始地址，value为卡表的索引号。记录谁指向我的原因是，如果仅仅收集部分年轻代，那么还需要扫描其他所有的年轻代区域，有了谁指向我，只需要扫描谁指向我的区域就可以了。

垃圾回收分为以下四个步骤：

初始标记：**标记出GC Roots能直接关联到的对象**。

并发标记：进行可达性分析。**只有此阶段是和用户线程用时并发，其他阶段都是STW**。

最终标记：修正并发标记阶段，标记变动的对象。

筛选回收：估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收。



## 调用System.gc() 虚拟机会直接立刻执行垃圾回收吗

1. 通过System.gc()者Runtime.getRuntime().gc() 的调用，**会显式触发Full GC**，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
2. 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(**不能确保立即生效**)

不会立即执行垃圾回收。



## 什么时候会触发GC

### MinorGC

Eden区域满了，或者新创建的对象大小大于Eden所剩空间

### Full GC

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）**方法区**空间不足
（4）发生Minor GC前，设置不允许风险，进入老年代的**平均大小大于老年代的可用内存**（空间担保策略失败）
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的**可用内存小于该对象大小**。



## jvm调优

## jps

jps [ -l ] 利用jps找出进程

### jstat 查看jvm统计信息

jstat -gc pid 可以查看年轻代中eden，survivor 或者老年代的容量，以及已使用的容量。gc的相关信息也会显示，年轻代、老年代gc次数以及所用时间

### jmap 查看堆内存的使用情况

jmap -heap pid 堆内存相关的一些参数设置以及各个区域的情况。

jmap -histo pid 按照对象占用内存空间的大小降序排列，把占用内存最多的对象放在最上面。

jmap -dump:format=b,file=<path> <pid>  在指定目录下生成一个 dump.hrpof 文件

### jstack 查看线程死锁信息

jstack pid 



# 树

## B树

B树，又称多路平衡查找树，B树中**所有结点的孩子个数的最大值称为B树的阶**，通常用 m 表示。一棵 m 阶 B 树或为空树，或为满足如下特性的 m 叉树:

1. 树中**每个结点至多有m棵子树，即至多含有m-1个关键字**。
2. 若根结点不是终端结点，则至少有两棵子树。
3. 除根结点外的所有非叶结点至少有 m/2(向上取整) 棵子树，即至少含有 m/2(向上取整)-1个关键字。
4. 所有的**叶结点都出现在同一层次上，并且不带信息**



![image-20210706152839924](牛客面试题.assets/image-20210706152839924.png)



## B+树

一棵m阶的B+树需满足下列条件:

1. 每个分支结点最多有m棵子树（孩子结点)。
2. 非叶根结点至少有两棵子树，其他每个分支结点至少有 m/2(向上取整) 棵子树。
3. **结点的子树个数与关键字个数相等**。
4. 所有**叶结点包含全部关键字及指向相应记录的指针**，叶结点中将关键字按大小顺序排列，
   并且相邻叶结点按大小顺序相互链接起来。
5. 所有**分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中**
   **关键字的最大值**及指向其子结点的指针。

![image-20210706153305466](牛客面试题.assets/image-20210706153305466.png)



## 红黑树

在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点**是红色或黑色**。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个**红色节点必须有两个黑色的子节点**。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从**任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点**。

![image-20210706153630279](牛客面试题.assets/image-20210706153630279.png)



# 设计模式

## 六大设计原则

单一职责原则：类的**功能要单一**，一个类只负责一个职责。

里氏替换原则：只要**父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常**，使用者可能根本就不需要知道是父类还是子类。

依赖倒置原则：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。在java中表现就是，**模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的**，这样就避免。如果类与类直接依赖细节，那么久会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。

接口隔离原则：不要建立庞大臃肿接口；尽量细化接口，接口中方法尽量少。也就是说，我们**要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类调用**。

迪米特法则：一个类应该对自己需要耦合或调用的类**知道得最少**。

开闭原则：**对拓展开放，对修改关闭**。



## 常用的设计模式

### 单例模式

#### 饿汉式

注意点：

+ **static final** 修饰单例对象
+ 构造方式 **private**
+ 获取单例对象的方法是 **static**

```java
public class Singleton2 {

    private static final Singleton2 instance = new Singleton2();

    private Singleton2() {
        
    }

    public static Singleton2 getInstance() {
        return instance;
    }
}

```



#### 懒汉式

##### 单线程

```java
public class Singleton1 {

    private static Singleton1 instance = null;

    private Singleton1() {
    }

    /**
     * 1、适用于单线程环境（不推荐）
     */
    public static Singleton1 getInstanceA() {
        if (null == instance) {
            instance = new Singleton1();
        }
        return instance;
    }
}

```



##### 多线程(低效率)

> 直接在方法上加 synchronized 关键字

```java
public class Singleton1 {

    private static Singleton1 instance = null;

    private Singleton1() {
    }

    /**
     * 2、适用于多线程环境，但效率不高（不推荐）
     */
    public static synchronized Singleton1 getInstanceB() {
        if (instance == null) {
            instance = new Singleton1();
        }
        return instance;
    }
}
```



##### 多线程双重检查加锁

> 当实例不存在，就加锁，加完锁之后再判断有没有存在，没存在就创建.
>
> 注意使用 **volitale** 修饰 instance

```java
public class Singleton1 {

    private static volatile Singleton1 instance = null;

    private Singleton1() {
    }

    /**
     * 3、双重检查加锁（推荐）
     */
    public static Singleton1 getInstanceC() {
        // 先判断实例是否存在，若不存在再对类对象进行加锁处理
        if (instance == null) {
            synchronized (Singleton1.class) {
                if (instance == null) {
                    instance = new Singleton1();
                }
            }
        }
        return instance;
    }
}
```



### 模板方法模式

一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。



### 享元模式

享元模式通过共享技术实现相同或相似对象的重用。

Integer中的私有静态内部类IntegerCache的静态代码块初始化 -128 到 127中的Integer对象保存在Integer类型的数组中。



### 工厂方法和抽象工厂

工厂方法的和抽象方法的**区别**是**一个产品抽象类还是多个产品抽象类**。

工厂方法：多个工厂类，**一个产品抽象类**，利用多态创建不同的产品对象

抽象方法：多个工厂类，**多个产品抽象类**，**产品子类分组**，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。

![image-20210706190426015](牛客面试题.assets/image-20210706190426015.png)



### 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。

```java
// 期望接口
public interface Target {
     //目标角色有自己的方法
     public void request();
}

// 已经存在的类
public class Adaptee {
     //原有的业务逻辑
     public void doSomething(){
             System.out.println("I'm kind of busy,leave me alone,pls!");
     }
}

// 适配器角色
public class Adapter extends Adaptee implements Target {
     public void request() {
             super.doSomething();
     }
}
```



## 原型模式

是用于创建重复的对象，同时又能保证性能。

实现了**clonable接口**

我们这里说的**浅拷贝是指我们拷贝出来的对象内部的引用类型变量和原来对象内部引用类型变量是同一引用**（指向同一对象）。 但是我们**拷贝出来的对象和新对象不是同一对象**。

避免浅拷贝，重写clone方法，自己实现引用变量的拷贝。




# rabbitmq

### 如何保证消息的顺序性

解决思路：在生产端发送消息的时候，**把自己上一条消息ID 记录到放到消息体**中。

​                      在消费端接收到消息后，首先检查**此消息中的 上一条消息ID属性**。

​                      如果**不存在上一条消息ID属性，那么就正常消费操作**。如果成功消费，则将此次消费的消息ID记录到数据库中。

​                      如果存在上一条消息ID属性，那么就先去数据库查看上一条消息是否已经成功被消费。

​                      	如果**上一条消息成功被消费，那么就执行正常的业务逻辑**。消费并记录本次消息ID。

​                      	如果发现**上一条消息没有被成功消费，那么可以稍等一下，在程序中执行睡眠X秒的操作。**当休眠时间到了以后，再去检查一下上一条消息是否已经被成功消费。如果此时上一条消息仍然没有成功消费，那么就抛出异常，**将当前的消息推回原队列，并等待下次重新消费**。



# Spring

## Spring生命周期

扫描XML、注解或者配置文件中需要被Spring需要管理的bean信息。将这些信息封装到BeanDefination中，保存到一个map中。可以通过实现的**BeanFactoryPostProcessor**方法对**BeanDefination中的信息做一些修改。**然后通过反射把对象实例化，但是这里并没有注入对象的属性。下面就是把对象的属性给注入进去，可以理解为Autowired注解已经解析完毕，依赖注入完成了。接下来就是初始化的工作：如果对象实现了aware接口就调用其中的方法，调用BeanPostProcessor的postProcessBeforeInitialization方法，如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法；如果Bean定义了 init-method 方法，则调用Bean的init-method方法；调用BeanPostProcessor的 postProcessAfterInitialization 方法



## Spring AOP

```java
/* 由于AspectJAwareAdvisorAutoProxyCreator实现了beanPostProcessor接口，所以会在初始化的阶段，调用init方法之后，调用这里面的postProcessAfterInitialization方法，返回一个代理对象。JdkDynamicAopProxy这个类中实现了InvocationHandler的接口，也就实现了invoke方法。
他先会把当前方法的前置后置通知，转变成一个过滤器链，（转变的过程是这样子后置通知，环绕通知以及异常通知继承了MethodInterceptor，其实也就是拦截器对象，直接返回去就可以了，但是有一些通知需要用相应的适配器转化为拦截器对象），拦截器的调用过程是递归调用。*/
```



## Spring MVC源码

DispatcherServlet是SpringMVC中的前端控制器(front controller)，负责接收request并将request转发给对应的处理组件。

HanlerMapping是SpringMVC中完成url到Controller映射的组件。DispatcherServlet接收request,然后从HandlerMapping查找处理request的controller。使用适配器适配一下controller，执行适配器执行controller进行处理

并返回ModelAndView对象，Controller是SpringMVC中负责处理request的组件(类似于struts2中的Action)，ModelAndView是封装结果视图的组件。

视图解析器解析ModelAndView对象并返回对应的视图给客户端。



## spring中用到的设计模式

### 单例模式

好处：对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

Spring注入Bean默认是单例的，将注册过的bean对象保存在concurrentHashMap中。用的时候，直接从里面拿就可以了。



### 适配器模式

spring mvc中的适配器模式：

实现原理：**HandlerAdapter根据Handler规则执行不同的Handler**

实现意义：**HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。**



单例模式：Spring依赖注入Bean实例默认是单例的。

使用三级缓存。分别是对象的工厂，未填充的对象，经过spring 完整生命周期的对象。



### 工厂方法模式：

实现方法：FactoryBean接口。

实现原理：实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。



### 代理模式

**Spring AOP 就是基于动态代理的**，如果要代理的对象，**实现了某个接口**，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就会使用**Cglib** 



## spring事务

### 事务的传播行为

+ REQUIRED：如果没有事务，就新建一个事务。如果有的话，就加入。
+ REQUIRES_NEW：没有就新建，有的话，把当前事务挂起。
+ SUPPORTS：有事务就加入，没有就以非事务方法执行
+ NOT_SUPPORTED：以非事务方式执行，存在事务就挂起事务
+ NEVER：以非事务方式执行，如果**当前存在事务，则抛出异常**。
+ MANDATORY：使用当前事务，**当前没有事务就抛异常**
+ NESTED：使用同一个物理事务，带有多个保存点，可以回滚到这些保存点，可以认为是部分回滚

### 事务失效的情况

+ 数据库**引擎不支持事务**，比如MyISAM
+ 当前类**没有加@Service**注解，不会被事务管理
+ 方法不是public的
+ 自身调用问题，没有加@Transactional注解的方法，调用了自身加了@Transactional注解的方法。就调该类自己的方法，而**没有经过 Spring 的代理类**
+ 内部使用try catch捕获了异常
+ spring事务只会对Error和RuntimeException进行回滚，而throw new **Exception**("更新错误")并不会产生回滚。可以在**rollbackFor = Exception.class**在发现Exception异常的时候也回滚。



# MyBatis

## Mybatis原理

以 User user = session.selectOne("com.heima.dao.IUserDao.findById", id) 为例

+ SqlSession根据 "com.heima.dao.IUserDao.findById" , 在configuration中获取到对应的MappedStatement对象，然后调用 executor 来执行具体的操作。
+ 根据传递的参数，完成SQL语句的动态解析，生成BoundSql ( select * from user where id = ? )对象，供StatementHandler使用；为查询创建缓存，以提高性能；StatementHandler委托ParameterHandler对占位符？进行设值，ResultHandler处理JDBC返回的resultSet，将resultSet加工为List 集合返回。（resultHandler 和 ParamaterHandler是在statementHandler中的）



## Mybatis 的# 和 $

#{} 使用占位符

${} 这边是直接进行进行字符串拼接的

## 一级缓存和二级缓存

### 一级缓存是如何实现的？

在 **BaseExector** 类中有 PerpetualCache 类型的localCache 变量，保存了查询语句的缓存，它里面其实也就是用 HashMap 实现缓存的。每次在查询数据库之前，会通过**mappedStatement的id，sql语句，参数，分页的limit和offset参数**生成一个cacheKey，如果 localCache 查询是不是这个key是不是有数据，如果有的话就说明当前的数据在里面，否则的话就不在。**每次插入删除更新都会清空这个缓存**。MyBatis一级缓存的生命周期和SqlSession一致

### 二级缓存如何实现的





# 杂七杂八

## 限流

令牌桶算法、漏桶算法、滑动窗口和计数器算法。



## 幂等性

1. 利用数据库的唯一约束或者唯一索引来实现

   常见的业务就是博客系统点赞功能，一个用户对一个博文点赞后，就**把用户 id 与 博文 id 绑定，后续该用户点赞同一个博文就无法插入了**，可以在数据表中设置用户 id 列为 UNIQUE，唯一约束。

2. 标识状态

   状态标识是很常见的幂等设计方式，**主要思路就是通过状态标识的变更，保证业务中每个流程只会在对应的状态下执行，如果标识已经进入下一个状态，这时候来了上一个状态的操作就不允许变更状态，保证了业务的幂等性。**

   最经典的例子就是订单系统，假如一个订单要经历 创建订单 ->  订单支付\取消 -> 账户计算 -> 通知商户 这四个步骤。那么就有可能一笔订单支付完成后去账户里扣除对应的余额，消耗对应的优惠卷。但是由于网络等原因返回了错误信息，这时候就会重试再次去进行账户计算步骤造成数据错误。所以为了保证整个订单流程的幂等性，可以**在订单信息中增加一个状态标识**，一旦完成了一个步骤就**修改对应的状态标识**。比如订单支付成功后，就把订单标识为修改为支付成功，现在再次调用订单支付或者取消接口，会先判断订单状态标识，如果是已经支付过或者取消订单，就不会再次支付了。

3. Token机制

   但是核心思想就是每次操作都**生成一个唯一 Token 凭证**，服务器通过这个唯一凭证保证同样的操作不会被执行两次。

   举个例子，在论坛中发布一个新帖子，要怎样防止用户多次点击提交导致产生多个同样的帖子呢。可以**让用户提交的时候带一个唯一 Token**，发布的时候将这个 Token 用redis保存起来，再次点击提交服务器只要判断该 Token 存在了就不允许提交，便能保证幂等性，避免同时提交多个帖子。注意的是 **Token 产生必须在用户提交内容之前**，比如进入编辑页面的时候生成 Token，用户在提交的时候内容带着 Token 一起提交，对于同一个页面无论用户提交多少次，就至多能成功一次。

   

# linux

### 什么是硬链接和软链接？



## 查看命令

```bash
head -n 5 filename # 显示开头五行

tail -n 5 filename # 显示最后五行

tail -n +5 filename # 从第五行开始显示

cat redis.conf | grep redis # 从cat中查看指定的元素
```





## 查看内存使用情况

top命令：可以查看到进程占用的虚拟内存、物理内存和共享内存。占用内存的百分比。

top -Hp pid 查看进程中线程的cpu情况

free命令：已使用的内存，可用的内存

cat /proc/meminfo

ps -ef | grep xxx：显示进程的id，无法显示进程的详细信息

ps - aux | grep xxx：显示进程的详细信息。



## 查看TCP连接情况

netstat 用于显示网络状况

netstat -napt 显示TCP传输协议的连线状况。

netstat -napu 显示UDP传输协议的连线状况。



## 十大排序算法

![img](牛客面试题.assets/sort.png)



# 项目

## 常用注解

```
// 异常
@ControllerAdvice // 开启全局异常
@ResponseBody // 返回的内容直接显示到浏览器页面
@ExceptionHandler(value = ApiException.class)

// 生命bean
@Component 组件，没有明确的角色
@Service 在业务逻辑层使用（service层）
@Repository 在数据访问层使用（dao层）
@Controller 在展现层使用，控制器的声明（C）

// 注入
@Autowired
@Resource
```

## 异常



## auth2.0

（A）用户访问客户端，后者将前者导向认证服务器。

（B）用户选择是否给予客户端授权。

（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。

（D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。

（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。



## 项目描述

使用了SpringBoot + Mybatis 完成了商城后台管理系统，使用SpringSecurity完成了用户的登录功能，使用了 jwt token完成了用户的登录功能，还配置了用户是否有权限访问该页面，定义自己的过滤器实现了AbstractSecurityInterceptor，然后内部配置自己设置的权限管理器(decide方法，如果未通过就抛出没有权限的异常)，和数据源（报错了所有路径需要的传入path，查找是否该路径的权限）。使用RabbitMQ完成了项目的订单超时未支付问题，每次产生订单就放进消息队列中，超过30分钟就转到另外一个队列中。同时也是用RabbitMq 完成用户的邮件注册功能，每当用户注册的话，就给用户发送一份邮件。使用redis保存字符串类型用户的登录信息，以及列表保存推荐商品。我们也使用了全局异常处理业务中的异常，自定义ApiException用户捕获全局异常，当发生一些业务的异常时抛出(比如说新建用户时，用户已存在。修改用户时，密码错误)，使用@ExceptionHandler注解捕获相应的异常。



### rabbitmq 延迟队列

设置两个队列，一个队列为TTL队列，同时设置它的交换机，以及路由，一个队列为订单取消队列。订单刚产生的时候，直接把订单的相关信息放到相关的TTL队列中，这个TTL队列是不设置消费者的，等到30分钟之后，会直接把消息发送给实际消费的队列，



### 使用redis存储用户的相关信息，以及推荐商品信息

使用字符串类型保存用户的信息 ums:admin:username

使用哈希类型保存推荐的商品信息，hvals 得到商品的所有信息。



### MySQL订单表和商品

多对多的关系，使用了中间表，它order_id字段加了索引。

用户的角色和资源也用了中间表



### springsecurity登录功能，页面访问权限功能

服务器拥有秘钥，判断当前的jwt是否的签名是不是可信的。

jwtfilter 首先判断用户的请求头中是否带有JwtToken头，

用户登录的时候，就会将他的用户信息保存的redis中。同时将用户的资源信息，也从数据库中查询出来，保存在数据库中。DynamicSecurityMetadataSource 继承 FilterInvocationSecurityMetadataSource，将**资源表下的路径，和权限名字保存到map中**，getAttributes方法获得**当前请求路径所需要的资源名字**。DynamicAccessDecisionManager获取当前登录用户的资源，判断是否有和这个路径需要的资源名称一样，有的话就可以访问，没有就不行。DynamicSecurityFilter 继承AbstractSecurityInterceptor拥有上面两个对象并且做一些其他的判断。

**通过下面的sql语句**获取管理员是否具有页面的请求资源权限。设置到redis中的resource资源中，同时当前用户的权限就被设置到UserDetail中了。当判断页面的时候，

```sql
SELECT
	ar.admin_id,
    ur.id id,
    ur.create_time createTime,
    ur.`name` `name`,
    ur.url url,
    ur.description description,
    ur.category_id categoryId
FROM
    ums_admin_role_relation ar
LEFT JOIN ums_role r ON ar.role_id = r.id
LEFT JOIN ums_role_resource_relation rrr ON r.id = rrr.role_id
LEFT JOIN ums_resource ur ON ur.id = rrr.resource_id
WHERE
    ar.admin_id = #{adminId}
AND ur.id IS NOT NULL
GROUP BY
    ur.id
```



登录流程：首先用户登录。判断用户的密码是否正确，如果正确的话， 就会根据服务器的秘钥产生相应的token字符串，这个字符串是根据登录用户名，以及当前的时间所产生的。下次访问的时候，直接在请求头中携带authorization字段，值是token，通过我们自己配置的jwtfilter，判断请求的请求头中是否携带authorization，如果没有就直接不做处理，携带的话就使用jwttoken来判断这个token是不是合法的，不合法的用户名就位空。如果用户名为空或者当前已经登录，直接dofilter就可以了，否则的话就需要通过userAdminServiceImpl通过用户名获取UserDetails设置到authentication中。



redis 保存key：

user:admin:用户名 ； user:resourceList

products id 信息



### 数据库

MySQL 表 用户表 角色表 资源表 菜单表(用户有哪些菜单权限) 他们中间通过关系表连接

商品订单 订单->退货申请->退货地址（无中间表），订单->操作历史 （无中间表）

限时购：限时购表（开始结束的日期，还包括是否启用）->显示场次(比如说早上几点到晚上几点) （有中间表）

商品审核记录、商品满减、商品折扣、产品买多件减价格、商品sku库存、产品的参数信息。(无中间表)

会员表->优惠券表->产品表->购物车表。